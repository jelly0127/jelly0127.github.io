<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
       
      <meta name="keywords" content="音乐、运动、游戏、代码、旅行" />
       
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> Jelly</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/log.jpg" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="Jelly" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/jelly0127"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/index.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">Jelly</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', 'Keep going', ''],
        startDelay: 0,
        typeSpeed: 300,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-useRef"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/01/29/useRef/"
    >useRef</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/01/29/useRef/" class="article-date">
  <time datetime="2023-01-29T15:26:01.000Z" itemprop="datePublished">2023-01-29</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>useRef其实就是函数组件的实例属性，在<strong>函数组件的生命周期内（或者说实例没有被销毁）</strong>始终存在且保持不变。</p>
<p><strong>useRef修改时候，并不会引起组件的刷新重渲染</strong></p>
<p><strong>Ref也可用作DOM节点的引用</strong></p>
<p><strong>Demo1</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">MyComponent</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> count = <span class="title function_">useRef</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;count.current = count.current +1&#125; &#125;&gt;count加1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>当前的count &#123;count.current&#125; <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，我们修改count的时候，p标签始终显示为0</p>
<p>Demo2</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">MyComponent</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> prev = <span class="title function_">useRef</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    prev.<span class="property">current</span> = count</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>setCount(count+1)&#125;&gt;count加1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>当前的count &#123;count&#125; <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>之前的count &#123;prev.current&#125; <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行可发现，即使我们prev.current &#x3D; count去修改ref值，但组件并没有重新渲染。</p>
<p><strong>详细执行过程</strong></p>
<ol>
<li>组件实例化，组件挂载。此时组件显示count &#x3D; 0 , prev &#x3D; 0</li>
<li>点击button，修改count，触发组件重新渲染</li>
<li>组件重新渲染，此时组件显示count &#x3D; 1, prev &#x3D; 0</li>
<li>组件重新渲染完成，执行effect，ref 被赋值成 1</li>
<li>此时组件并没有重新渲染，程序按照我们预期的执行。</li>
</ol>
<p>访问Demo</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Component</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> $Buttom = <span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">ref</span>=<span class="string">&#123;$Buttom&#125;</span>&gt;</span>button<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>console.log($Buttom.current)&#125;&gt;print<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果需要访问子组件中的dom呢?使用React.forwardRef</strong></p>
<p>React.forwardRef 是React中一个高阶组件，高阶组件内部会帮组件注入接收到ref， 且作为函数组件的第二个参数使用。（与React.useImperativeHandlek一起使用）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子组件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Child</span> = <span class="title class_">React</span>.<span class="title function_">forwardRef</span>(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="title class_">React</span>.<span class="title function_">useImperativeHandle</span>(ref, <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">		<span class="attr">handleData</span>: <span class="string">&#x27;我是子组件的数据&#x27;</span></span><br><span class="line">	&#125;))</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Child</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//父组件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Parent</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">	<span class="keyword">const</span> childrenRef= useRef&lt;any&gt;()</span><br><span class="line">	<span class="keyword">let</span> childData = childrenRef.<span class="property">current</span>.<span class="property">handleData</span><span class="comment">// 得到子组件的数据</span></span><br><span class="line">	<span class="keyword">return</span> (</span><br><span class="line">		<span class="language-xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">ref</span>=<span class="string">&#123;childrenRef&#125;</span> /&gt;</span></span></span><br><span class="line">	)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用React.createRef有什么区别</strong></p>
<ul>
<li>效果上没有区别</li>
<li>性能上，createRef 在函数每次重新渲染的时候都会重新创建一个ref对象，而useRef不会。</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-useMemo"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/01/29/useMemo/"
    >useMemo</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/01/29/useMemo/" class="article-date">
  <time datetime="2023-01-29T15:25:05.000Z" itemprop="datePublished">2023-01-29</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>useMemo用于保存<strong>复杂</strong>计算的结果。</p>
<p>useMemo与useCallback使用场景特别相似，都是用于性能优化，不同的是useMemo返回的是一个值，而useCallback返回的是一个函数。</p>
<p>假设我们有MyComponent以及Counter两个组件，以及一个复杂计算函数Fibonacci</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">MyComponent</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> [step, setStep] = <span class="title function_">useState</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [data, setData] = <span class="title function_">useState</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>setStep(step+3)&#125;&gt;step加3<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>setData(data+1)&#125;&gt;data加1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Counter</span> <span class="attr">step</span>=<span class="string">&#123;step&#125;</span> <span class="attr">data</span>=<span class="string">&#123;data&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params">&#123;step,data&#125;</span>)&#123;</span><br><span class="line">  <span class="comment">// 使用useMemo保存计算结果</span></span><br><span class="line">  <span class="comment">// const result = useMemo(() =&gt; Fibonacci(step), [step])</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 不使用useMemo保存计算结果</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="title class_">Fibonacci</span>(step)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;data&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;result&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Fibonacci</span>(<span class="params">step</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(step==<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(step==<span class="number">2</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Fibonacci</span>(step-<span class="number">1</span>) + <span class="title class_">Fibonacci</span>(step-<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行情况分两种情况：</p>
<ul>
<li><p>不使用useMemo保存计算结果</p>
</li>
<li><ul>
<li>在step值加到40以上的时候，明显感受到result变量计算缓慢</li>
<li>只修改data状态，Couter组件重新渲染，已经发生卡顿，原因在于Couter重新计算了result变量，但其实在不改变step的情况下，result不应该重新计算。</li>
</ul>
</li>
<li><p>使用useMemo保存计算结果</p>
</li>
<li><ul>
<li>在step值加到40以上的时候，明显感受到result变量计算缓慢</li>
<li>只修改data状态，组件渲染依旧流畅，原因是result依赖项没有发生改变，result没有重新计算。</li>
</ul>
</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-useCallback"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/01/29/useCallback/"
    >useCallback</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/01/29/useCallback/" class="article-date">
  <time datetime="2023-01-29T15:24:17.000Z" itemprop="datePublished">2023-01-29</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p> 众所周知（有实际动手实验），React的函数组件再每次渲染的时候，都会执行一遍一整个函数数组，来获取返回的渲染后的VDom，如果我们在函数内部声明了一个函数，那么该函数在每次重渲染的时候都会重新声明。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">MyComponent</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">getData</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;...&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">    	<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Component<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以观察到，每次刷新渲染的时候getData函数都会重新声明。</p>
<h2 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">MyComponent</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [toggle, setToggle] = <span class="title function_">useState</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">CallBack</span> = <span class="title function_">useCallback</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(count)</span><br><span class="line">  &#125;, [toggle])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>setCount(count+1)&#125;&gt;点我count+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>setToggle(!toggle)&#125;&gt;点我重新生成callBack<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;CallBack&#125;</span>&gt;</span>点我调用Func<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当count改变的时候，CallBack始终打印的是0</li>
<li>当第一次点击重新生成CallBack时候，打印的结果就是最新的count值</li>
</ul>
<p><strong>讲到这，不得不提一下React一个神级高阶组件API，React.memo</strong></p>
<p>在使用React过程中，发现React有个让我十分恶心的设计。</p>
<p>就是父组件一旦刷新，那么子组件全部都重新渲染。</p>
<p>假设我有一个组件FatherA，以及两个子组件ChildrenA与ChildrenB</p>
<p>很容易发现，假设FatherA 只是修改了name，没有修改age，依赖name的ChildrenA刷新了能接受，依赖了age没有依赖name的ChildrenB也一起刷新了，这就不能忍了😡</p>
<p>我们可以使用React.memo稍加改造ChildrenA与ChildrenB。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">ChildrenA</span> = <span class="title class_">React</span>.<span class="title function_">memo</span>(<span class="function">(<span class="params">&#123;name&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;子组件A挂载了&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;子组件A卸载了&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      我的名字是&#123;name&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;,<span class="function">(<span class="params">prev, next</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(prev.<span class="property">name</span> === next.<span class="property">name</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ChildrenB</span> = <span class="title class_">React</span>.<span class="title function_">memo</span>(<span class="function">(<span class="params">&#123;age&#125;</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;子组件B挂载了&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;子组件B卸载了&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      我的年龄是&#123;age&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;,<span class="function">(<span class="params">prev,next</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(prev.<span class="property">age</span> === next.<span class="property">age</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>以上是memo这个API的标准写法，其实例子中memo的第二个参数可以省略（只需要<strong>浅层对比</strong>）:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">ChildrenA</span> = <span class="title class_">React</span>.<span class="title function_">memo</span>(<span class="function">(<span class="params">&#123;name&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;子组件A挂载了&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;子组件A卸载了&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      我的名字是&#123;name&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ChildrenB</span> = <span class="title class_">React</span>.<span class="title function_">memo</span>(<span class="function">(<span class="params">&#123;age&#125;</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;子组件B挂载了&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;子组件B卸载了&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      我的年龄是&#123;age&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>可以实现同样的效果。</p>
<p>哈哈哈哈哈，难过的东西都没有了🎉</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-useContext"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/01/29/useContext/"
    >useContext</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/01/29/useContext/" class="article-date">
  <time datetime="2023-01-29T15:23:28.000Z" itemprop="datePublished">2023-01-29</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>提供给函数组件访问Context的能力。PS：全局跨组件通信，在顶级组件中声明传递，包裹需通信的子组件。</p>
<p>Demo</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MyContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>(&#123;&#125;)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">APP</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [ data, setData ] = <span class="title function_">useState</span>(<span class="string">&#x27;jelly&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">MyContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;&#123;</span> <span class="attr">data</span>, <span class="attr">setData</span> &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">Children</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">MyContext.Provider</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Children</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; data, setData &#125; = <span class="title function_">useContext</span>(<span class="title class_">MyContext</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    我接收到的context是&#123;data&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&#123;data&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;(e)</span>=&gt;</span>setData(e.target.value)&#125;&gt;<span class="tag">&lt;/<span class="name">input</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>useContext接收Context对象，返回Context的内容。</li>
<li>可以直接引入其他文件创建的Context对象，而不用担心Context对象不同，因为模块变量具有<strong>单例</strong>特性。</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-useState"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/01/29/useState/"
    >useState</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/01/29/useState/" class="article-date">
  <time datetime="2023-01-29T15:22:25.000Z" itemprop="datePublished">2023-01-29</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h2><p>用于给函数组件添加状态，状态一旦发生改变，会触发组件的重渲染（销毁-&gt;获取最新的props-&gt;渲染）。</p>
<p><strong>注意，这里的props是重新获取的。</strong></p>
<p>useState返回数组，数组第一项为<code>state</code>， 第二项为<code>useState</code></p>
<p>useState告诉React，什么数据需要React帮助我们去记录，只有这些被记录的数据发生改变的时候， 才帮助我们需重新渲染组件，组件的重渲染会引发<strong>所有</strong>子组件的重渲染。</p>
<p><strong>状态以及变量</strong></p>
<ul>
<li><p>只有影响程序的最终输出结果的，才属于状态。</p>
</li>
<li><p>普通变量不会影响程序最终输出结果，称为普通变量。</p>
</li>
<li><p>状态应该最小化。</p>
</li>
</ul>
<p><strong>大量数据</strong></p>
<p>我们常常有这么一个业务场景。</p>
<ul>
<li>请求一个完整的数据对象，以表单形式呈现数据对象的全部字段，对数据对象进行修改并且提交。</li>
</ul>
<p>我们用<code>useState是这样的</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">JSX</span><br><span class="line">useEffect(()=&gt;&#123;</span><br><span class="line">  API.getData().then(res=&gt;&#123;</span><br><span class="line">      setdata(res)</span><br><span class="line">  &#125;) </span><br><span class="line">&#125;,[])</span><br><span class="line"></span><br><span class="line">const [data, setData] = useState(&#123;&#125;);</span><br><span class="line"></span><br><span class="line">// data</span><br><span class="line">//&#123;</span><br><span class="line">//    name:&#x27;jelly&#x27;,</span><br><span class="line">//    age:18,</span><br><span class="line">//    skill:[</span><br><span class="line">//      &#123;</span><br><span class="line">//        name:&#x27;HTML&#x27;,</span><br><span class="line">//        level:1</span><br><span class="line">//      &#125;,</span><br><span class="line">//      &#123;</span><br><span class="line">//        name:&#x27;CSS&#x27;,</span><br><span class="line">//        level:2</span><br><span class="line">//      &#125;</span><br><span class="line">//    ]</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure>



<p>实际上，这并不符合<code>useState</code>设计原则，数据结构过于复杂了，且如果直接使用<code>setSatet</code>更新，需要每次对数据进行深拷贝，但实际上，业务场景的数据结构会更加复杂。</p>
<p>对此有几种解决方案：</p>
<ol>
<li><p>对数据进行拆解，拆分称多个state</p>
</li>
<li><p>使用<code>useReducer</code></p>
</li>
</ol>
<p>先来看拆分<code>state</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">JSX</span><br><span class="line">useEffect(()=&gt;&#123;</span><br><span class="line">  API.getData().then(res=&gt;&#123;</span><br><span class="line">      setname(res.name)</span><br><span class="line">      setage(res.age)</span><br><span class="line">      setskill(res.skill)</span><br><span class="line">  &#125;) </span><br><span class="line">&#125;,[])</span><br><span class="line"></span><br><span class="line">const [name, setName] = useState(&#x27;&#x27;);</span><br><span class="line">const [age, setAge] = useState(-1);</span><br><span class="line">const [skill, setSkill] = useState([]);</span><br></pre></td></tr></table></figure>



<p>这么做虽然让我们更新state方便了许多，但也导致我们代码十分冗余，且提交的时候又需要手动收集一份数据，简直就是一坨💩。</p>
<p>那么如果使用<code>useReducer呢</code>，一样不是最佳解决方案</p>
<ul>
<li><p>依旧无法绕开深拷贝这件事。</p>
</li>
<li><p>有点大材小用，很多时候我们仅仅是为了深度更新某个值，且这些逻辑并不会复用于其他组件。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">JSX</span><br><span class="line">function ReducerTest() &#123;</span><br><span class="line">  const action = (state,action) =&gt; &#123;</span><br><span class="line">    const _state = JSON.parse(JSON.stringify(state))</span><br><span class="line">    switch (action.type) &#123;</span><br><span class="line">      case &#x27;name&#x27;:</span><br><span class="line">        _state.name = &#x27;tom&#x27;</span><br><span class="line">        break;</span><br><span class="line">      default:</span><br><span class="line">        _state.age = 0</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    return _state</span><br><span class="line">  &#125;</span><br><span class="line">  const [data,Dispatch] = useReducer(action,&#123;</span><br><span class="line">    name: &#x27;jelly&#x27;,</span><br><span class="line">    age: 19</span><br><span class="line">  &#125;);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;&#123;data.name&#125;&lt;/p&gt;</span><br><span class="line">      &lt;p&gt;&#123;data.age&#125;&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;()=&gt;Dispatch(&#123;type:&#x27;name&#x27;&#125;)&#125;&gt;点我修改名字&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;()=&gt;Dispatch(&#123;type:&#x27;age&#x27;&#125;)&#125;&gt;点我修改年龄&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>immer.js</strong></p>
<p>这是新认识的库但未在上线项目中实践过，但是看说明貌似能够给我们带来极大的好处：</p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5e0968ed51882549766f3b9b">2020要用immer来代替immutable优化你的React项目</a></p>
<ul>
<li><p>防止组件在调用<code>setState</code>设置与原来相同值的情况下进行更新</p>
</li>
<li><p>更易用的<code>setState</code></p>
</li>
</ul>
<p>光是一点易用的setState，其实已经光芒四射了，减去了相对于复杂的处理</p>
<p>一个简易的DEMO</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">JSX</span></span><br><span class="line"><span class="keyword">import</span> produce <span class="keyword">from</span> <span class="string">&#x27;immer&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> array = [&#123;<span class="attr">value</span>: <span class="number">0</span>&#125;, &#123;<span class="attr">value</span>: <span class="number">1</span>&#125;, &#123;<span class="attr">value</span>: <span class="number">2</span>&#125;];</span><br><span class="line"><span class="keyword">const</span> arr = <span class="title function_">produce</span>(array, <span class="function"><span class="params">draft</span> =&gt;</span> &#123;</span><br><span class="line">  draft[<span class="number">0</span>].<span class="property">value</span> = <span class="number">10</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr === array);</span><br></pre></td></tr></table></figure>



<p>我们可以使用&#96;useImmer来代替useState（个人现阶段较为喜欢的一种方式，第三方成熟稳定的自定义Hooks）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">JSX</span></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="variable constant_">API</span>.<span class="title function_">getData</span>().<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">setData</span>(res)</span><br><span class="line">  &#125;) </span><br><span class="line">&#125;,[])</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [data, setData] = <span class="title function_">useImmer</span>(&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">setData</span>(<span class="function"><span class="params">state</span>=&gt;</span>&#123;</span><br><span class="line">  state.<span class="property">name</span> = <span class="string">&#x27;jelly&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>非常容易的进行state深度更新，并且旧的数据会重用，不会刷新所有子组件（需要配合<code>React.memo</code>）。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-useEffect"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/01/29/useEffect/"
    >useEffect</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/01/29/useEffect/" class="article-date">
  <time datetime="2023-01-29T15:20:34.000Z" itemprop="datePublished">2023-01-29</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h2><p>表面当前组件<strong>渲染完成包括DOM挂载</strong>，需要执行的<strong>副作用操作</strong>。</p>
<p><strong>不要尝试用生命周期的方式去理解useEffect，这会使得事情变得十分复杂</strong></p>
<p>接收两个参数，一个是回调函数，一个是依赖数据。</p>
<ul>
<li>回调函数effect，表明需要执行的函数操作</li>
<li>依赖数据，数组，表明所依赖的数据变化，只有当数组中的数据发生了改变，才会执行effect函数</li>
</ul>
<p>React 将按照 effect 声明的顺序依次调用组件中的每一个 effect</p>
<p><strong>时机</strong></p>
<ol>
<li>组件首次挂载完成</li>
<li>执行 <code>effect</code></li>
<li>组件状态改变 ，即将卸载</li>
<li>执行<code>effect</code>返回值函数</li>
<li>组件重新挂载完成</li>
<li>执行 <code>effect</code></li>
<li>组件卸载</li>
<li>执行 <code>effect</code> 返回值函数</li>
<li>实例销毁</li>
</ol>
<p><strong>流程</strong></p>
<p>effect-&gt;effect返回值函数-&gt;effect-&gt;effect返回值函数</p>
<p><strong>副作用</strong></p>
<p>指的是函数影响了其函数(<strong>effect自身</strong>)作用域之外的数据，比如修改了数据库，修改了浏览器的title等等。</p>
<p><strong>effect</strong></p>
<p>effect函数作为Hook组件内部用于处理一系列副作用操作，同时effect可以返回一个函数，React会帮助我们记录它就好像记录你的许多state一样，直到你的组件卸载或销毁了，React会去调用这个返回的函数。</p>
<p><strong>Capture Value</strong></p>
<p>函数组件之间存在状态隔离，我们称这个现象为函数的 <strong>Capture Value</strong> ，或者我们称React这种行为叫<strong>按帧渲染</strong>。</p>
<p>假设我们有这么一个<code>effect</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [ num, setNum ] = <span class="title function_">useState</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(num)</span><br><span class="line">&#125;, [num])</span><br></pre></td></tr></table></figure>



<p>其实这个effect会被React内部保存成</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">()=&gt;&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这样一看貌似没什么问题，但是如果遇到一些异步的函数比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(num)</span><br><span class="line">  &#125;,<span class="number">3000</span>)</span><br><span class="line">&#125;,[num])</span><br></pre></td></tr></table></figure>



<p>我们希望在num发生改变后，组件重新渲染，effect三秒后打印num。</p>
<p>但是在计时器等待的期间，num被修改了多次。</p>
<p>三秒后，计时器打印的是三秒前的num，而期间多次改变的数据依旧会依次打印出来。</p>
<p>这是因为， React内部，<code>effect</code> 函数已经被保存成了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">()=&gt;&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">  &#125;,<span class="number">3000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>不要试图去欺骗React</strong></p>
<p>很多时候我们会在<code>effect</code> 函数内部去依赖外部的数据，React官方指出我们需要在<code>useEffect</code>第二个数组参数内表明我们在<code>effect</code>函数内部所依赖的数据，这是因为<code>effect</code>会作为帧的方式进行保存，帧之间的作用域是隔离的，React需要对函数内部的变量转化成常量。</p>
<p>比如我们有这样的代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure>



<p>我们希望effect在组件渲染完毕后只执行一次，在组件销毁时候同时也销毁定时器，但是我们内部依旧是依赖了<code>count</code>这个状态。</p>
<p>显然我们这么做有点投机取巧，且这样代码并不会如期运行，count始终会被设置成同一个常量。</p>
<p>那如果我们将count添加进依赖里面。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">&#125;, [count]);</span><br></pre></td></tr></table></figure>



<ul>
<li>重复的创建定时器，重复销毁定时器，造成性能浪费。</li>
</ul>
<p>这貌似得不偿失，我们可以利用State的特性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(<span class="function">(<span class="params">count</span>)=&gt;</span>count+<span class="number">1</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure>



<p>移除了外部依赖，访问的永远是内部的count，这样的effect就不存在问题了。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-ReactHook全家桶"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/01/29/ReactHook%E5%85%A8%E5%AE%B6%E6%A1%B6/"
    >ReactHook全家桶</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/01/29/ReactHook%E5%85%A8%E5%AE%B6%E6%A1%B6/" class="article-date">
  <time datetime="2023-01-29T15:16:16.000Z" itemprop="datePublished">2023-01-29</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>坐标：深圳    职位：前端开发</p>
<p>只要有时间就持续更新叭，记录前端成长路线…</p>
<p>经过大概三个月的ReactHooks学习与实践，发现其实Hooks在项目中的开发过程并不是那么流畅，项目质量不佳，很多认为是细小的事实在Hooks上不断打脸，留步总结其实是主要问题在于</p>
<ul>
<li>Vue思想带到了React上，试图模拟 watch, filter，emit 等一系列React不存在的概念。</li>
<li>想通过Hooks完整还原类组件实例的效果，但其实函数组件的思想与类组件思想是不同的。</li>
<li>想通过Hooks还原类实例生命周期的概念。</li>
<li>小白起步边学边开发，忽略过多细节导致回头补救太多，代码质量差。</li>
<li>单个Hooks组件设计过于单一束缚，兼容性差。</li>
<li>单个Hooks组件过于复杂化，导致复用性差。</li>
<li>没有很好的发挥自定义Hooks带来的逻辑抽离的便利性。</li>
<li>没有深入理解纯函数开发概念。</li>
<li>并没有很深入的去理解ReactAPP的设计哲学，未磨刀先砍柴。</li>
</ul>
<p>这次深入Hooks细节，从头学习一次ReactHooks。</p>
<p>要学的东西没有很多，花费我们大量学习时间的是在用一件事上反反复复的学习回归。</p>
<p>在此之前，仔细阅读并消化：<a target="_blank" rel="noopener" href="https://react-1251415695.cos-website.ap-chengdu.myqcloud.com/docs/thinking-in-react.html">React哲学</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>Hooks组件不是类组件的语法糖，其React内部实现逻辑是不同的。</strong></p>
<p>关于函数组件的<strong>生命周期</strong>， 没有类组件那么复杂，只是简单的挂载，卸载。</p>
<p>每次组件刷新都是一次 <strong>卸载 -&gt; 挂载</strong> 的过程</p>
<p>挂载 -&gt; 卸载 -&gt; 挂载 -&gt; 卸载</p>
<p>在函数组件内，<strong>实例</strong>与<strong>vdom</strong>其实是两个不同的概念</p>
<p>可以认为的是，每个组件实例始终一致（只要组件不被<strong>销毁</strong>），每次刷新会产生不同的<code>vdom</code>，但是实例始终保持不变。</p>
<p><strong>销毁</strong></p>
<p>组件彻底在你的ReactAPP消失，这称为实例的销毁，组件的<code>state</code>所占用的内存空间会被回收。</p>
<p>那么组件在什么时候会被销毁呢？组件被条件渲染给pass掉了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> show ? <span class="language-xml"><span class="tag">&lt;<span class="name">Children</span>/&gt;</span></span> : <span class="literal">null</span></span><br></pre></td></tr></table></figure>



<p><strong>卸载</strong></p>
<p>组件并没有消失，只是组件的<code>state</code> 发生改变，组件被重新渲染了，重新渲染的过程就是一次 <strong>卸载 -&gt; 挂载</strong> 的过程。</p>
<p>那么组件在怎么时候卸载呢？组件状态更新重新挂载之前，或者组件实例销毁之前。</p>
<p><strong>实例这个概念是React通过Hooks赋予函数组件的，在这之前函数组件只是无状态视图组件，而我们把React保存函数state，ref的内存空间称为函数组件实例</strong></p>
<p><strong>组件到底是依赖props才更新还是自身的state?</strong></p>
<ul>
<li>只依赖自身的state，你可以认为组件的props其实是父组件的state。</li>
</ul>
<p>其实很容易误区的是，并不是一且props改变都会引发重新渲染。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ChildrenComponent</span>(<span class="params">props</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;props.count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  count ++</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(count)</span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">ChildrenComponent</span> <span class="attr">count</span>=<span class="string">&#123;count&#125;/</span>&gt;</span></span>,</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;app&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<p>可以观察到，<code>ChildrenComponent</code> 的props一值在改变，控制台不断打印最新的<code>count</code> 值， 但是组件却不会刷新。</p>
<ul>
<li>其实React并不会帮助我们去监听<code>props</code>的变化，只有<code>setState</code>的调用，才会导致React去帮助我们刷新。</li>
<li>子组件props改变的刷新是由于父组件刷新引起，这其实是两个概念，很容易形成误区。</li>
<li>React不存在<strong>监听</strong>的概念，这是Vuejs的概念。</li>
</ul>
<p>（点击标签链接即可跳转详情页）</p>
<h2 id="主要的Hooks"><a href="#主要的Hooks" class="headerlink" title="主要的Hooks"></a>主要的Hooks</h2><ol>
<li>[useEffect](<a target="_blank" rel="noopener" href="https://www.yuque.com/docs/share/43255f81-7cd7-41a1-9ba4-2ae156574561#">https://www.yuque.com/docs/share/43255f81-7cd7-41a1-9ba4-2ae156574561?#</a> 《ReactHook -1 (useEffect)》)</li>
<li>[useState](<a target="_blank" rel="noopener" href="https://www.yuque.com/docs/share/b24d8722-b076-4c0a-bec4-5ba66e72248f#">https://www.yuque.com/docs/share/b24d8722-b076-4c0a-bec4-5ba66e72248f?#</a> 《ReactHooks-2 (useState)》)</li>
<li>[useContext](<a target="_blank" rel="noopener" href="https://www.yuque.com/docs/share/9df3bafb-a95c-48b0-84da-88850185d316#">https://www.yuque.com/docs/share/9df3bafb-a95c-48b0-84da-88850185d316?#</a> 《ReactHooks-3（useContext）》)</li>
<li>[useCallback](<a target="_blank" rel="noopener" href="https://www.yuque.com/docs/share/249af995-df27-405d-96fe-a9cd132cea9d#">https://www.yuque.com/docs/share/249af995-df27-405d-96fe-a9cd132cea9d?#</a> 《ReactHooks-4 (useCallback)》)</li>
<li>[useMemo](<a target="_blank" rel="noopener" href="https://www.yuque.com/docs/share/e97efda4-a3f8-4023-b81a-cfe361777e7f#">https://www.yuque.com/docs/share/e97efda4-a3f8-4023-b81a-cfe361777e7f?#</a> 《ReactHooks-5 (useMemo)》)</li>
<li>[useref](<a target="_blank" rel="noopener" href="https://www.yuque.com/docs/share/145a57a2-007f-490b-93f2-470a6254b30b#">https://www.yuque.com/docs/share/145a57a2-007f-490b-93f2-470a6254b30b?#</a> 《ReactHooks-6 (useRef)》)</li>
<li>[自定义Hooks](<a target="_blank" rel="noopener" href="https://www.yuque.com/docs/share/fa421744-8256-4b78-9266-d4fa4227d26d#">https://www.yuque.com/docs/share/fa421744-8256-4b78-9266-d4fa4227d26d?#</a> 《ReactHooks-自定义Hook》)</li>
</ol>
<h2 id="React路由"><a href="#React路由" class="headerlink" title="React路由"></a>React路由</h2><p>[react-router(v6)](<a target="_blank" rel="noopener" href="https://www.yuque.com/docs/share/b9e1f021-1692-46f9-a206-23ce5abdbb99#">https://www.yuque.com/docs/share/b9e1f021-1692-46f9-a206-23ce5abdbb99?#</a> 《React-router（V6）》)</p>
<h2 id="React状态机"><a href="#React状态机" class="headerlink" title="React状态机"></a>React状态机</h2><p>[React-rudex](</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-uniapp"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/01/29/uniapp/"
    >uniapp</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/01/29/uniapp/" class="article-date">
  <time datetime="2023-01-29T15:11:49.000Z" itemprop="datePublished">2023-01-29</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>uniapp的开发目的是一套代码多端使用，但是个人兼容性差，实用性不是很强，生态对其它框架来说较弱。但毕竟是国内开发的产品还是希望它可以发展更好更完善。</p>
<p>特点：</p>
<p>与vue框架的使用基本一致，但又有微信小程序的一些影子。个人觉得是两个东西的结合加工品。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-微信云开发"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/01/29/%E5%BE%AE%E4%BF%A1%E4%BA%91%E5%BC%80%E5%8F%91/"
    >微信云开发</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/01/29/%E5%BE%AE%E4%BF%A1%E4%BA%91%E5%BC%80%E5%8F%91/" class="article-date">
  <time datetime="2023-01-29T15:10:51.000Z" itemprop="datePublished">2023-01-29</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="一，认识小程序云开发"><a href="#一，认识小程序云开发" class="headerlink" title="一，认识小程序云开发"></a>一，认识小程序云开发</h1><h2 id="1-1，云开发简介"><a href="#1-1，云开发简介" class="headerlink" title="1-1，云开发简介"></a>1-1，云开发简介</h2><ul>
<li>小程序·云开发是微信团队联合腾讯云推出的专业的小程序开发服务。 </li>
<li>开发者可以使用云开发快速开发小程序、小游戏、公众号网页等，并且原生打通微信开放能力。 </li>
<li>开发者无需搭建服务器，可免鉴权直接使用平台提供的API进行业务开发<br>  小程序 </li>
<li>云开发又简称tcb，是微信官方给我们提供的基于腾讯云的云服务器。目前云开发包含：云数据库，云函数，云存储，云调用。后面章节会具体给大家讲解这几个。</li>
</ul>
<p>官方文档：<a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/getting-started.html">https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/getting-started.html</a><br><img src="https://img-blog.csdnimg.cn/20210119094307797.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="1-2，云开发和传统服务器对比"><a href="#1-2，云开发和传统服务器对比" class="headerlink" title="1-2，云开发和传统服务器对比"></a>1-2，云开发和传统服务器对比</h2><p>云开发相对于传统服务器的优势如下表<br><img src="https://img-blog.csdnimg.cn/20210118140545909.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>通过上面的对比，我们可以看出，如果你想快速创建一个小程序的后台，用云开发是不错的选择。</p>
<h2 id="1-3，Serverless开发模式"><a href="#1-3，Serverless开发模式" class="headerlink" title="1-3，Serverless开发模式"></a>1-3，Serverless开发模式</h2><p>要想深入了解小程序云开发，就需要知道什么是Serverless开发模式，因为我们的小程序云开发就是采用的这个模式<br>官方视频有讲到：<a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/community/business/doc/000e8697e481208a2e3b31d6a5680d">https://developers.weixin.qq.com/community/business/doc/000e8697e481208a2e3b31d6a5680d</a><br>所以我们接下来要深入了解下Serverless开发模式</p>
<h3 id="1-3-1，前端开发模式的演进"><a href="#1-3-1，前端开发模式的演进" class="headerlink" title="1-3-1，前端开发模式的演进"></a>1-3-1，前端开发模式的演进</h3><p><img src="https://img-blog.csdnimg.cn/246cc0ea2b13496c8227142068aab3fc.png" alt="img"></p>
<p>上图说完了这几个阶段，可以看到，每一次前端开发模式的变化，都因某个变革性的技术而起。先是 AJAX，而后是 Node.js。那么下一个变革性的技术是什么？不言而喻，个人觉得下一代前端开发模式就是 Serverless</p>
<p>其实 Serverless 早已和前端产生了联系，只是我们可能没有感知。<br>1、CDN: 相信大家都使用过 CDN，我们开发完成之后，直接将静态文件部署到 CDN 上，通过 CDN 进行内容分发、网络加速，在这个过程中，前端不需要关心 CDN 有多少个节点、如何做负载均衡，也不需要知道 CDN 的 QPS 是多少。所以从这个角度来说，CDN 是一种 serverless 的实现。<br>2、再比如对象存储，和 CDN 一样，我们只需要将文件上传到对象存储，就可以直接使用了，不需要关心它如何存取文件、如何进行权限控制，所以对象存储对前端来说是 Serverless。<br>3、甚至一些第三方的 API 服务，也是 Serverless，因为我们使用的时候，不需要去关心服务器。</p>
<h3 id="1-3-2，什么是Serverless"><a href="#1-3-2，什么是Serverless" class="headerlink" title="1-3-2，什么是Serverless"></a>1-3-2，什么是Serverless</h3><p><img src="https://img-blog.csdnimg.cn/1ce8bb2923014ce9bd91cda1337c0244.png" alt="img"><br>从技术角度来说，Serverless 就是 FaaS 和 BaaS 的结合。<br>简单来讲，FaaS（Function as a Service） 就是一些运行函数的平台，比如云开发里的云函数，阿里云的函数计算、AWS 的 Lambda 等。</p>
<p>BaaS（Backend as a Service）则是一些后端云服务，比如云开发数据库、对象存储、消息队列等。利用 BaaS，可以极大简化我们的应用开发难度。</p>
<p>Serverless 则可以理解为运行在 FaaS 中，使用了 BaaS 的函数。</p>
<h3 id="1-3-3，Serverless-的主要特点"><a href="#1-3-3，Serverless-的主要特点" class="headerlink" title="1-3-3，Serverless 的主要特点"></a>1-3-3，Serverless 的主要特点</h3><p>1、事件驱动—-函数在 FaaS 平台中，需要通过一系列的事件来驱动函数执行。<br>2、无状态—-因为每次函数执行，可能使用的都是不同的容器<br>3、无运维—-使用serverless我们不需要关心服务器，也不需要关心运维，这也是serverles思想的核心；<br>4、低成本—-使用 Serverless 成本很低，因为我们只需要为每次函数的运行付费。函数不运行，则不花钱，也不会浪费服务器资源过度</p>
<h3 id="1-3-4，serverless-开发流程"><a href="#1-3-4，serverless-开发流程" class="headerlink" title="1-3-4，serverless 开发流程"></a>1-3-4，serverless 开发流程</h3><p><img src="https://img-blog.csdnimg.cn/52f3ba4c862b4c42bc82e63799f8f143.png" alt="img"><br>通过上图就可以看出<br>1，传统开发流程。<br>在传统开发流程中，我们需要前端写页面，后端工程师写接口。后端写完接口之后，把接口部署了，再进行前后端联调。联调完毕后再测试、上线。上线之后，还需要运维工程师对系统进行维护。整个过程涉及多个不同角色，链路较长，沟通协调也是一个问题。</p>
<p>2、而基于 Serverless，后端变得非常简单了，以往的后端应用被拆分为一个个函数，只需要写完函数并部署到 Serverless 服务即可，后续也不用关心任何服务器的运维操作。后端开发的门槛大幅度降低了。因此，只需要一个前端就可以完成所有的开发工作。<br>当然，前端基于 Serverless 去写后端，最好也需要具备一定的后端知识。涉及复杂的后端系统或者 Serverless 不适用的场景，还是需要后端开发</p>
<h3 id="1-3-5，serverless带来的价值"><a href="#1-3-5，serverless带来的价值" class="headerlink" title="1-3-5，serverless带来的价值"></a>1-3-5，serverless带来的价值</h3><p>1．降低运营复杂度</p>
<p>Serverless架构使软件应用和服务器实现了解耦，服务器不再是用户开发和运营应用的焦点。在应用上线前，用户无须再提前规划服务器的数量和规格。在运维过程中，用户无须再持续监控和维护具体服务器的状态，只需要关心应用的整体状态。应用运营的整体复杂度下降，用户的关注点可以更多地放在软件应用的体验和改进以及其他能带来更高业务价值的地方。<br>2．降低运营成本<br>服务器不再是用户关注的一个受管资源，运营的复杂度下降，应用运营所需要投入的时间和人力将大大降低。在最好的情况下，可以做到少数几个应用管理员即可管理一个处理海量请求的应用系统。</p>
<p>3、缩短产品的上市时间<br>在Serverless架构下，应用的功能被解构成若干个细颗粒度的无状态函数，功能与功能之间的边界变得更加清晰，功能模块之间的耦合度大大减小。这使得软件应用的开发效率更高，应用开发的迭代周期更短。</p>
<h3 id="1-3-6，基于-Serverless-的小程序开发"><a href="#1-3-6，基于-Serverless-的小程序开发" class="headerlink" title="1-3-6，基于 Serverless 的小程序开发"></a>1-3-6，基于 Serverless 的小程序开发</h3><p>1、目前国内使用 Serverless 较多的场景可能就是小程开发了。具体的实现就是小程序云开发，支付宝小程序和微信小程序都提供了云开发功能。<br>2、在传统的小程序开发中，我们需要前端进行小程序端的开发；后端进行服务端的开发。小程序的后端开发和其他的后端应用开发，本质是是一样的，需要关心应用的负载均衡、备份冗灾、监控报警等一些列部署运维操作。如果开发团队人很少，可能还需要前端去实现服务端。<br>但基于云开发，就只需要让开发者关注于业务的实现，由一个前端就能够完成整个应用的前后端开发。因为云开发将后端封装为了 BaaS 服务，并提供了对应的 SDK 给开发者，开发者可以像调用函数一样使用各种后端服务。应用的运维也转移到了提供云开发的服务商。<br>下面分别是使用支付宝云开发的一些例子，函数就是定义在 FaaS 服务中的函数。</p>
<p>负载均衡（Load Balance）其意思就是分摊到多个操作单元上进行执行，例如Web服务器、FTP服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务<br>备份冗灾：就是为了防止出现自然或者社会灭害带来的对存储设备的损害而造成对数据丢失,而采取的备份.</p>
<h3 id="1-3-7，通用-Serverless-架构"><a href="#1-3-7，通用-Serverless-架构" class="headerlink" title="1-3-7，通用 Serverless 架构"></a>1-3-7，通用 Serverless 架构</h3><p><img src="https://img-blog.csdnimg.cn/2073a7990d3b4f45b61418859111c46b.png" alt="img"><br>其中最底层就是实现复杂业务的后端微服务（Backend）。然后 FaaS 层通过一系列函数实现业务逻辑，并为前端直接提供服务。对于前端开发者来说，前端可以通过编写函数的方式来实现服务端的逻辑。</p>
<p>同时不管是在后端、FaaS 还是前端，我们都可以去调用云计算平台提供的 BaaS 服务，大大降低开发难度、减少开发成本。小程序云开发，就是直接在前端调用 BaaS 服务的例子。</p>
<p>一句话总结serverless - less is more<br>使用 Serverless，我们不需要再过多关注服务端的运维，不需要关心我们不熟悉的领域，我们只需要专注于业务的开发、专注于产品的实现。我们需要关心的事情变少了，但我们能做的事情更多了。</p>
<h1 id="二，云开发环境的创建与初始化"><a href="#二，云开发环境的创建与初始化" class="headerlink" title="二，云开发环境的创建与初始化"></a>二，云开发环境的创建与初始化</h1><p>注意事项</p>
<ul>
<li>1,必须注册小程序后才可以开通云开发</li>
<li>2,一个小程序可以创建两个云开发环境</li>
</ul>
<h2 id="2-1-创建一个初始项目"><a href="#2-1-创建一个初始项目" class="headerlink" title="2-1,创建一个初始项目"></a>2-1,创建一个初始项目</h2><p>我们要开通云开发服务，必须先要进入小程序开发者工具才可以。最新版的开发者工具在创建项目时又多了一个模板选择，如果你用的是最新版的开发者工具，模板选择里就选择不使用模板即可。</p>
<h3 id="最新版的开发工具不使用模板"><a href="#最新版的开发工具不使用模板" class="headerlink" title="最新版的开发工具不使用模板"></a>最新版的开发工具不使用模板</h3><p>如果你用的是最新版的开发者工具，创建项目时会多一个模板选择，这里一定要记得选择不使用模板。</p>
<p>关于appid</p>
<p>如果你不使用自己的appid创建项目，就会出现下面的问题，所以一定要先去注册一个小程序，然后用自己的appid。</p>
<p>由于云开发官方更新的太快，有些同学可能会遇到下面这样的问题<br>没有 不使用云服务 选型。</p>
<h2 id="2-2，没有“不使用云服务”选型解决方案-选看"><a href="#2-2，没有“不使用云服务”选型解决方案-选看" class="headerlink" title="2-2，没有“不使用云服务”选型解决方案(选看)"></a>2-2，没有“不使用云服务”选型解决方案(选看)</h2><p>如果你出现上面的问题，再看这节，如果没出现这样的问题，直接跳过就行。</p>
<p>把这个模板下载到桌面，并解压。</p>
<p>链接: <a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1UJLAwlvM46_MvpC96FwKPg">https://pan.baidu.com/s/1UJLAwlvM46_MvpC96FwKPg</a> 提取码: 1234 </p>
<p>–来自百度网盘超级会员v2的分享<br>然后点击导入，把项目导入即可。<br>appid换成自己的。</p>
<h2 id="2-3-开通云开发"><a href="#2-3-开通云开发" class="headerlink" title="2-3,开通云开发"></a>2-3,开通云开发</h2><ul>
<li><p>1,点击下图箭头所示,如果你第一步创建项目时,没有使用自己的appid,这里不会有下图箭头所示的云朵.<br><img src="https://pic.imgdb.cn/item/63d68bd6face21e9ef509844.png"></p>
</li>
<li><p>2,给云开发环境取名</p>
<p>等待创建<br><img src="https://img-blog.csdnimg.cn/img_convert/4e0a7c2e116e9bf6d5154140351e7a48.png" alt="img"><br>创建成功<br><img src="https://pic.imgdb.cn/item/63d68be7face21e9ef50c1bc.png"></p>
</li>
</ul>
<h2 id="2-4-初始化云开发环境-重要"><a href="#2-4-初始化云开发环境-重要" class="headerlink" title="2-4,初始化云开发环境(***重要)"></a>2-4,初始化云开发环境(***重要)</h2><p>在app.js里写入环境id,注意这里要用你自己的云开发环境id</p>
<ul>
<li>初始化云开发环境前，先去云开发控制台，拿到云开发环境id</li>
</ul>
<p>  这里的环境id建议直接复制，不要手写，很容易写错。 </p>
<ul>
<li>拿到环境id以后，就去app.js里做云开发环境初始化，</li>
</ul>
<p>用时候云开发创建好以后,初始化可能需要一点时间,所以如果这里初始化有报错,记得关闭开发者工具,等几分钟再重新打开即可.</p>
<h1 id="三，云开发-云数据库"><a href="#三，云开发-云数据库" class="headerlink" title="三，云开发~云数据库"></a>三，云开发~云数据库</h1><p>官方文档：<a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/wxcloud/guide/database/init.html">https://developers.weixin.qq.com/miniprogram/dev/wxcloud/guide/database/init.html</a></p>
<h2 id="3-1，在数据库里新建集合-数据表"><a href="#3-1，在数据库里新建集合-数据表" class="headerlink" title="3-1，在数据库里新建集合(数据表)"></a>3-1，在数据库里新建集合(数据表)</h2><p>我们这里以新建一个商品列表为例<br><img src="https://img-blog.csdnimg.cn/20210119143131206.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="3-2，数据库权限管理"><a href="#3-2，数据库权限管理" class="headerlink" title="3-2，数据库权限管理"></a>3-2，数据库权限管理</h2><p>要想让用户查询到我们创建的商品数据，需要把权限改为所有用户可读<br><img src="https://img-blog.csdnimg.cn/20210119144339469.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="3-3，数据库的增删改查"><a href="#3-3，数据库的增删改查" class="headerlink" title="3-3，数据库的增删改查"></a>3-3，数据库的增删改查</h2><h3 id="3-3-1，查询-get"><a href="#3-3-1，查询-get" class="headerlink" title="3-3-1，查询 get()"></a>3-3-1，查询 get()</h3><ul>
<li>传统写法<br><img src="https://img-blog.csdnimg.cn/2021011914394249.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></li>
<li>ES6简洁写法<br><img src="https://img-blog.csdnimg.cn/20210119145203891.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>推荐第二种写法<br><img src="https://img-blog.csdnimg.cn/20210119150828859.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></li>
</ul>
<h3 id="3-3-2，条件查询-where"><a href="#3-3-2，条件查询-where" class="headerlink" title="3-3-2，条件查询 where()"></a>3-3-2，条件查询 where()</h3><p><img src="https://img-blog.csdnimg.cn/2021011915165530.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="3-3-3，查询单条数据doc"><a href="#3-3-3，查询单条数据doc" class="headerlink" title="3-3-3，查询单条数据doc()"></a>3-3-3，查询单条数据doc()</h3><p>doc是用来查询单条数据的。比如商品详情页。<br>doc里面用到的参数就是我们数据里的_id字段<br><img src="https://img-blog.csdnimg.cn/20210120105842707.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="3-3-4，添加数据-add"><a href="#3-3-4，添加数据-add" class="headerlink" title="3-3-4，添加数据 add()"></a>3-3-4，添加数据 add()</h3><p>通过add可以实现数据的添加，<br><img src="https://img-blog.csdnimg.cn/2021012011072216.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="3-3-5，更新数据update"><a href="#3-3-5，更新数据update" class="headerlink" title="3-3-5，更新数据update()"></a>3-3-5，更新数据update()</h3><p>修改数据库里已存在的数据，结合doc进行修改单条数据<br><img src="https://img-blog.csdnimg.cn/20210120111452950.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="3-3-6，删除数据remove"><a href="#3-3-6，删除数据remove" class="headerlink" title="3-3-6，删除数据remove()"></a>3-3-6，删除数据remove()</h3><p>删除数据，结合doc删除单条数据<br><img src="https://img-blog.csdnimg.cn/20210120111942981.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="4-4，增删改查综合案例"><a href="#4-4，增删改查综合案例" class="headerlink" title="4-4，增删改查综合案例"></a>4-4，增删改查综合案例</h2><ul>
<li>1，能查看商品列表</li>
<li>2，更动态添加商品</li>
<li>3，能进入商品详情页</li>
<li>4，能删除某个商品</li>
<li>5，能修改某个商品的价格</li>
</ul>
<h3 id="4-4-1-列表跳详情-data"><a href="#4-4-1-列表跳详情-data" class="headerlink" title="4-4-1 列表跳详情 data-"></a>4-4-1 列表跳详情 data-</h3><ul>
<li>1，在wxml里定义data- 要绑定的数据<br><img src="https://img-blog.csdnimg.cn/20210120115030960.png" alt="img"></li>
<li>2， 在js页面里的点击方法里拿到绑定的数据<br><img src="https://img-blog.csdnimg.cn/20210120115046577.png" alt="img"></li>
<li>比如打印结果如下<br><img src="https://img-blog.csdnimg.cn/20210120115105901.png" alt="img"></li>
</ul>
<h3 id="4-4-2，列表跳详情并携带商品id"><a href="#4-4-2，列表跳详情并携带商品id" class="headerlink" title="4-4-2，列表跳详情并携带商品id"></a>4-4-2，列表跳详情并携带商品id</h3><ul>
<li>1，列表跳页到详情页<br><img src="https://img-blog.csdnimg.cn/20210120115627866.png" alt="img"></li>
<li>2，拿到列表跳页时携带的id数据<br><img src="https://img-blog.csdnimg.cn/20210120115911259.png" alt="img"></li>
</ul>
<h3 id="4-4-3，查询商品列表"><a href="#4-4-3，查询商品列表" class="headerlink" title="4-4-3，查询商品列表"></a>4-4-3，查询商品列表</h3><p><img src="https://img-blog.csdnimg.cn/20210121105411410.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="4-4-4，添加商品并刷新商品列表"><a href="#4-4-4，添加商品并刷新商品列表" class="headerlink" title="4-4-4，添加商品并刷新商品列表"></a>4-4-4，添加商品并刷新商品列表</h3><p><img src="https://img-blog.csdnimg.cn/20210121105450835.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="4-4-5，更新商品数据"><a href="#4-4-5，更新商品数据" class="headerlink" title="4-4-5，更新商品数据"></a>4-4-5，更新商品数据</h3><p>用户输入新价格，调用update方法进行更新数据<br><img src="https://img-blog.csdnimg.cn/20210121111158518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>我们更新成功的时候，会有如下所示的日志打印。<br><img src="https://img-blog.csdnimg.cn/20210122103005208.png" alt="img"><br>只有stats里的updated是1的时候，才代表成功的更新了一条数据。<br>如果这条商品不是你创建的，当你对这条商品做更新操作时，打印的updated就是0。<br><img src="https://img-blog.csdnimg.cn/20210122103355106.png" alt="img"><br>这个时候代表没有更新成功。这是因为操作时的权限问题，要解决这个问题，就要借助云函数了，这里我们先放在这里，在后面云函数章节会做具体讲解。</p>
<h3 id="4-4-6，弹窗提示确认是否删除"><a href="#4-4-6，弹窗提示确认是否删除" class="headerlink" title="4-4-6，弹窗提示确认是否删除"></a>4-4-6，弹窗提示确认是否删除</h3><p>用户删除数据是一个危险操作，所以操作之前最好给用户一个友好提示。<br>官方弹窗文档：<a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/api/ui/interaction/wx.showModal.html">https://developers.weixin.qq.com/miniprogram/dev/api/ui/interaction/wx.showModal.html</a></p>
<p><img src="https://img-blog.csdnimg.cn/20210122165835203.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="4-4-7，删除商品"><a href="#4-4-7，删除商品" class="headerlink" title="4-4-7，删除商品"></a>4-4-7，删除商品</h3><p><img src="https://img-blog.csdnimg.cn/202101221714103.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="4-4-8，更新和删除时的权限问题"><a href="#4-4-8，更新和删除时的权限问题" class="headerlink" title="4-4-8，更新和删除时的权限问题"></a>4-4-8，更新和删除时的权限问题</h3><p>如果这条商品不是你创建的，当你对这条商品做删除或者更新操作时，虽然也会返回成功，但是可以看到我们更新或者删除的条数是0。<br><img src="https://img-blog.csdnimg.cn/20210122103703603.png" alt="img"><br><img src="https://img-blog.csdnimg.cn/202101221715036.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>其实这个时候也意味着没有更新或者删除成功，这里是因为操作权限的问题，因为这条数据不是你创建的。所以你只能对这条数据做查询操作，而不能做修改和删除操作。要想解决这个问题，就要借助云函数了。后面云函数讲解的部分，我会做具体讲解的。</p>
<p><strong>我们还是先接着学习数据库操作的高级操作</strong></p>
<h2 id="4-5，常用快捷键"><a href="#4-5，常用快捷键" class="headerlink" title="4-5，常用快捷键"></a>4-5，常用快捷键</h2><p>我们在开发时为了提高代码编写效率，通常会使用一些快捷键。我们小程序开发工具里常用的快捷键。<br>设置—》快捷键设置</p>
<p>然后点击如下快捷键即可查看所有的快捷键</p>
<p>如果感觉默认的快捷键不喜欢，可以自己重新设置快捷键。由于自带的快捷比较多，我这里不一一列举了，我把一些常用的快捷键拿出来给大家大致讲一讲，我这里以window电脑为例，如果你mac电脑，可以自己去看下开发者工具默认的快捷键。多看几遍把常用的记住就行了。</p>
<table>
<thead>
<tr>
<th>快捷键组合</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl+a</td>
<td>全选</td>
</tr>
<tr>
<td>Ctrl+c</td>
<td>复制选中内容</td>
</tr>
<tr>
<td>Ctrl+v</td>
<td>粘贴复制的内容</td>
</tr>
<tr>
<td>Ctrl+z</td>
<td>撤销当前编辑</td>
</tr>
<tr>
<td>Ctrl+s</td>
<td>保存并编译项目</td>
</tr>
<tr>
<td>Ctrl+b</td>
<td>重新编译项目</td>
</tr>
<tr>
<td>Ctrl+x</td>
<td>截切选中的内容</td>
</tr>
<tr>
<td>Ctrl+&#x2F;</td>
<td>添加注释</td>
</tr>
<tr>
<td>Ctrl+Shift+k</td>
<td>删除当前行</td>
</tr>
<tr>
<td>Ctrl+Shift+f</td>
<td>全局搜索</td>
</tr>
<tr>
<td>Ctrl+f</td>
<td>当前页面内搜索</td>
</tr>
<tr>
<td>Ctrl+Shift+h</td>
<td>全局搜索并替换文本</td>
</tr>
<tr>
<td>Ctrl+h</td>
<td>当前页面内搜索并替换文本</td>
</tr>
<tr>
<td>Shift+Alt+F</td>
<td>格式化代码</td>
</tr>
<tr>
<td>Shift+Alt+⬆</td>
<td>向上复制当前行</td>
</tr>
<tr>
<td>Shift+Alt+⬇</td>
<td>向下复制当前行</td>
</tr>
<tr>
<td>Alt+⬆</td>
<td>把当前行向上移动一行</td>
</tr>
<tr>
<td>Alt+⬇</td>
<td>把当前行向下移动一行</td>
</tr>
</tbody></table>
<p>有的电脑上快捷键可能会有细微差距，以开发者工具默认自带的快捷键为准。</p>
<h2 id="4-6，数据库排序orderBy"><a href="#4-6，数据库排序orderBy" class="headerlink" title="4-6，数据库排序orderBy"></a>4-6，数据库排序orderBy</h2><p>orderBy方法在做排序的时候，接受两个参数</p>
<ul>
<li>1，根据那个字段排序</li>
<li>2，排序规则（升序或者降序）。升序用asc，降序用desc</li>
</ul>
<p>如我们根据商品价格从低到高升序排列<br><img src="https://img-blog.csdnimg.cn/20210125110343465.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>如我们根据商品价格从高到低降序排列<br><img src="https://img-blog.csdnimg.cn/20210125110402219.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="4-7，返回指定条数的数据limit"><a href="#4-7，返回指定条数的数据limit" class="headerlink" title="4-7，返回指定条数的数据limit"></a>4-7，返回指定条数的数据limit</h2><p>limit用来指定查询结果集数量上限，比如我们有100条数据，只想返回前20条，我们可以通过limit(20)来指定只返回20条数据。</p>
<p>例如，只返回3条数据的写法如下<br><img src="https://img-blog.csdnimg.cn/20210125111539268.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<ul>
<li>注意：limit 在小程序端默认及最大上限为 20，在云函数端默认及最大上限为 1000</li>
</ul>
<h2 id="4-8，分页方法skip"><a href="#4-8，分页方法skip" class="headerlink" title="4-8，分页方法skip"></a>4-8，分页方法skip</h2><p>skip指定查询返回结果时从指定序列后的结果开始返回，常用于分页。比如我们有100条数据，想从第10条开始返回数据，可以通过skip(10)来实现</p>
<ul>
<li>skip结合我们上面学的limit方法可以实现分页效果<br><img src="https://img-blog.csdnimg.cn/20210125112437110.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></li>
</ul>
<p>比如我们有100条数据，每次返回20条数据。那么就可以分5页返回。</p>
<ul>
<li>第1页 limit(20).skip(0)</li>
<li>第2页 limit(20).skip(20)</li>
<li>第3页 limit(20).skip(40)</li>
<li>第4页 limit(20).skip(60)</li>
<li>第5页 limit(20).skip(80)</li>
</ul>
<h2 id="4-9，Command数据库操作符"><a href="#4-9，Command数据库操作符" class="headerlink" title="4-9，Command数据库操作符"></a>4-9，Command数据库操作符</h2><p>我门上面学完了数据库的增删改查，但是这些都是最基础最简单的操作，如果我们想实现复杂的数据查询操作，该怎么办呢<br>比如</p>
<ul>
<li>查询价格大于100的商品？</li>
<li>查询年龄小于18岁的学生？</li>
<li>如何同时修改多条数据？</li>
<li>如何同时删除多条数据？</li>
</ul>
<p>我们如果想实现上面这些复杂的操作，就需要用到数据库里的 Command数据库操作符，就是下面这位<br><img src="https://img-blog.csdnimg.cn/2021012009455233.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>官方文档：<a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/wxcloud/reference-sdk-api/database/Command.html">https://developers.weixin.qq.com/miniprogram/dev/wxcloud/reference-sdk-api/database/Command.html</a></p>
<h3 id="4-9-1，gt查询大于指定值的数据"><a href="#4-9-1，gt查询大于指定值的数据" class="headerlink" title="4-9-1，gt查询大于指定值的数据"></a>4-9-1，gt查询大于指定值的数据</h3><p>比如查询价格大于5的所有商品<br><img src="https://img-blog.csdnimg.cn/20210127165116544.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="4-9-2，gte查询大于等于指定值的数据"><a href="#4-9-2，gte查询大于等于指定值的数据" class="headerlink" title="4-9-2，gte查询大于等于指定值的数据"></a>4-9-2，gte查询大于等于指定值的数据</h3><p>比如查询大于等于5元的商品<br><img src="https://img-blog.csdnimg.cn/20210127165315512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="4-9-3，lt查询小于指定数值的数据"><a href="#4-9-3，lt查询小于指定数值的数据" class="headerlink" title="4-9-3，lt查询小于指定数值的数据"></a>4-9-3，lt查询小于指定数值的数据</h3><p>比如查询价格小于5的所有商品<br><img src="https://img-blog.csdnimg.cn/20210127165629116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="4-9-4，lte查询小于等于指定数值的数据"><a href="#4-9-4，lte查询小于等于指定数值的数据" class="headerlink" title="4-9-4，lte查询小于等于指定数值的数据"></a>4-9-4，lte查询小于等于指定数值的数据</h3><p>比如查询价格小于等于5元的所有商品<br><img src="https://img-blog.csdnimg.cn/20210127165656903.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="4-9-5，and同时满足多个条件的查询"><a href="#4-9-5，and同时满足多个条件的查询" class="headerlink" title="4-9-5，and同时满足多个条件的查询"></a>4-9-5，and同时满足多个条件的查询</h3><p>比如查询价格大于5小于10元的所有商品<br><img src="https://img-blog.csdnimg.cn/20210127171011932.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<h1 id="四，云开发-云函数"><a href="#四，云开发-云函数" class="headerlink" title="四，云开发~云函数"></a>四，云开发~云函数</h1><h2 id="4-1，认识云函数"><a href="#4-1，认识云函数" class="headerlink" title="4-1，认识云函数"></a>4-1，认识云函数</h2><p>官方文档：<a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/wxcloud/guide/functions.html">https://developers.weixin.qq.com/miniprogram/dev/wxcloud/guide/functions.html</a></p>
<p>我们先来看下官方给出的云函数简介<br><img src="https://img-blog.csdnimg.cn/20210128101348674.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>其实通俗来讲，云函数也是运行在服务器上的，只不过和我们传统开发语言相比。微信官方为我们提供的傻瓜式的一键部署。也就是说你只需要把心思花在业务逻辑代码的编写上即可。无需关心写好如何部署，无需关心安全问题，无需关心鉴权问题。</p>
<h3 id="4-1-1，云函数获取openid"><a href="#4-1-1，云函数获取openid" class="headerlink" title="4-1-1，云函数获取openid"></a>4-1-1，云函数获取openid</h3><p>用云函数的话，只需要3步</p>
<ul>
<li>1，编写云函数</li>
<li>2，一键部署云函数</li>
<li>3，调用云函数</li>
</ul>
<p>来看下云函数代码，只需要10行代码，即可轻松搞定<br><img src="https://img-blog.csdnimg.cn/20210128103312772.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="4-2，云函数的优势"><a href="#4-2，云函数的优势" class="headerlink" title="4-2，云函数的优势"></a>4-2，云函数的优势</h2><p>我们用云函数和上一章的云数据库进行下对比</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>云函数</th>
<th>云数据库</th>
</tr>
</thead>
<tbody><tr>
<td>返回数据上限</td>
<td>100条</td>
<td>20条</td>
</tr>
<tr>
<td>更新数据</td>
<td>都可以更新</td>
<td>只有自己创建的才可以更新</td>
</tr>
<tr>
<td>删除数据</td>
<td>都可以删除</td>
<td>只有自己创建的才可以删除</td>
</tr>
<tr>
<td>运行环境</td>
<td>运行在云端Node.js环境</td>
<td>运行在小程序本地</td>
</tr>
<tr>
<td>实现功能丰富度</td>
<td>非常丰富</td>
<td>只能实现数据库增删改查</td>
</tr>
</tbody></table>
<ul>
<li>来看下官方文档是如何描述云函数的<br>云函数属于管理端，在云函数中运行的代码拥有不受限的数据库读写权限和云文件读写权限。需特别注意，云函数运行环境即是管理端，与云函数中的传入的 openId 对应的微信用户是否是小程序的管理员 &#x2F; 开发者无关。</li>
</ul>
<h2 id="4-3，云函数调用演示"><a href="#4-3，云函数调用演示" class="headerlink" title="4-3，云函数调用演示"></a>4-3，云函数调用演示</h2><p>官方文档：<a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/wxcloud/reference-sdk-api/functions/Cloud.callFunction.html">https://developers.weixin.qq.com/miniprogram/dev/wxcloud/reference-sdk-api/functions/Cloud.callFunction.html</a></p>
<h3 id="4-3-0-初始化云函数的环境"><a href="#4-3-0-初始化云函数的环境" class="headerlink" title="4-3-0,初始化云函数的环境"></a>4-3-0,初始化云函数的环境</h3><ul>
<li>1，创建一个文件夹cloud和pages平行<br><img src="https://img-blog.csdnimg.cn/20210128112140139.png" alt="img"></li>
<li>2，在project.config.json里面配置云函数所在目录为cloud<br>在project.config.json里面添加如下配置<img src="https://img-blog.csdnimg.cn/20210128112324919.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>然后点击保存，我们的cloud文件夹前面就有一个云朵<br><img src="https://img-blog.csdnimg.cn/20210128112426173.png" alt="img"><br>就代表我们云函数初始化成功啦。</li>
<li>新一个云函数<br><img src="https://img-blog.csdnimg.cn/20210128113128483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></li>
<li>如果只创建一个云函数的时候，会出现下面的问题。<br><img src="https://img-blog.csdnimg.cn/20210128113247938.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>解决方案：只需要在cloud文件夹下新建一个空白文件即可。</li>
</ul>
<h3 id="4-3-1，云函数获取openid"><a href="#4-3-1，云函数获取openid" class="headerlink" title="4-3-1，云函数获取openid"></a>4-3-1，云函数获取openid</h3><p>调用云函数有两种写法</p>
<ul>
<li>1，传统的success和fail<br><img src="https://img-blog.csdnimg.cn/20210128114458871.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></li>
<li>2，用promise写法then和catch<br><img src="https://img-blog.csdnimg.cn/20210128114704240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></li>
</ul>
<h3 id="4-3-2，数据的导入和导出"><a href="#4-3-2，数据的导入和导出" class="headerlink" title="4-3-2，数据的导入和导出"></a>4-3-2，数据的导入和导出</h3><ul>
<li><p>数据导出，做数据备份<br><img src="https://img-blog.csdnimg.cn/20210128121013973.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>比如导入为json数据如下<br><img src="https://img-blog.csdnimg.cn/20210128121110249.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
</li>
<li><p>数据导入，为了快速的大量的创建一些数据。</p>
<p>把这108条数据的json文件，导入到数据库如下<br><img src="https://img-blog.csdnimg.cn/202101281236396.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
</li>
</ul>
<h3 id="4-3-3，云函数获取数据"><a href="#4-3-3，云函数获取数据" class="headerlink" title="4-3-3，云函数获取数据"></a>4-3-3，云函数获取数据</h3><p>注意：云函数只要有变动，就要重新部署，否则云函数不生效。</p>
<p>遇到了一个问题，如下<br><img src="https://img-blog.csdnimg.cn/20210128115406470.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>出现原因：如果你有两个云开发环境，偶尔会出现上图所示的问题。<br>解决问题：有两种</p>
<ul>
<li>1，在云函数里指定你要使用那个云开发环境<br><img src="https://img-blog.csdnimg.cn/20210128115654705.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></li>
<li>2，使用DYNAMIC_CURRENT_ENV常量 （提倡使用这个）<br><img src="https://img-blog.csdnimg.cn/20210128115926399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>我们这里会和小程序里直接调用数据库的查询进行下对比<br><img src="https://img-blog.csdnimg.cn/20210128120452944.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210128124103359.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="4-3-4，云函数修改数据"><a href="#4-3-4，云函数修改数据" class="headerlink" title="4-3-4，云函数修改数据"></a>4-3-4，云函数修改数据</h3><p>本地小程序直接调用数据库修改会有问题</p>
<ul>
<li>只能修改自己创建的数据，别人创建的数据，就没有办法修改了。<br>  <img src="https://img-blog.csdnimg.cn/20210129164121371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"> </li>
<li>如何解决呢？ 用云函数来修改就可以解决这个问题啦。 </li>
<li>1，先创建云函数update0129<br>  <img src="https://img-blog.csdnimg.cn/20210129164236714.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"> </li>
<li>2,调用云函数就行修改<br>  <img src="https://img-blog.csdnimg.cn/20210129164221501.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></li>
</ul>
<h3 id="4-3-5，云函数删除数据"><a href="#4-3-5，云函数删除数据" class="headerlink" title="4-3-5，云函数删除数据"></a>4-3-5，云函数删除数据</h3><ul>
<li>1,创建一个删除商品的云函数remove0129<br><img src="https://img-blog.csdnimg.cn/20210129165537372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></li>
<li>2,调用这个云函数进行删除操作<br><img src="https://img-blog.csdnimg.cn/20210129165609854.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></li>
</ul>
<h3 id="4-3-6，提交数据到云函数"><a href="#4-3-6，提交数据到云函数" class="headerlink" title="4-3-6，提交数据到云函数"></a>4-3-6，提交数据到云函数</h3><ul>
<li>1，创建云函数，并部署<br><img src="https://img-blog.csdnimg.cn/20210129170423649.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></li>
<li>2，调用云函数<br><img src="https://img-blog.csdnimg.cn/20210129170445839.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></li>
</ul>
<h2 id="4-4-使用云函数常见问题"><a href="#4-4-使用云函数常见问题" class="headerlink" title="4-4,使用云函数常见问题"></a>4-4,使用云函数常见问题</h2><h3 id="4-4-1，云函数里面没有初始化环境变量"><a href="#4-4-1，云函数里面没有初始化环境变量" class="headerlink" title="4-4-1，云函数里面没有初始化环境变量"></a>4-4-1，云函数里面没有初始化环境变量</h3><p><img src="https://img-blog.csdnimg.cn/20210129165211243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>解决方案如下：<br>使用DYNAMIC_CURRENT_ENV<br><img src="https://img-blog.csdnimg.cn/20210129165244946.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>代码片段</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cloud.init(&#123;</span><br><span class="line">  env: cloud.DYNAMIC_CURRENT_ENV </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h1 id="五，云开发-云存储"><a href="#五，云开发-云存储" class="headerlink" title="五，云开发~云存储"></a>五，云开发~云存储</h1><p>首先来看下官方对云存储的介绍：<br>官方文档：<a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/wxcloud/guide/storage.html">https://developers.weixin.qq.com/miniprogram/dev/wxcloud/guide/storage.html</a><br><img src="https://img-blog.csdnimg.cn/20210201161044364.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>说白了，云存储就是可以用来存储视频，音频，图片，文件的一个云存储空间。如果你的小程序需要用到视频播放，音频播放，图片展示，文件上传与下载功能，就可以用到我们的云存储了。</p>
<ul>
<li>使用云存储来存储文件时，文件名的命名有一些规则，建议看一下。<br><img src="https://img-blog.csdnimg.cn/20210201162210831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></li>
</ul>
<h2 id="5-1，云开发控制台管理文件"><a href="#5-1，云开发控制台管理文件" class="headerlink" title="5-1，云开发控制台管理文件"></a>5-1，云开发控制台管理文件</h2><p>控制台也可以很方便的管理文件。<br><img src="https://img-blog.csdnimg.cn/20210202111303938.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="5-2，上传图片到云存储"><a href="#5-2，上传图片到云存储" class="headerlink" title="5-2，上传图片到云存储"></a>5-2，上传图片到云存储</h2><p>我们上传图片之前需要先选择图片，所以这里用到一个图片选择的功能<br><img src="https://img-blog.csdnimg.cn/20210201162803725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>对应的官方文档：<a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/api/media/image/wx.chooseImage.html">https://developers.weixin.qq.com/miniprogram/dev/api/media/image/wx.chooseImage.html</a><br><img src="https://img-blog.csdnimg.cn/20210201162833775.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>然后调用文件上传的api接口即可<br><img src="https://img-blog.csdnimg.cn/20210201163026521.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>官方文档：<a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/wxcloud/reference-sdk-api/storage/uploadFile/client.uploadFile.html">https://developers.weixin.qq.com/miniprogram/dev/wxcloud/reference-sdk-api/storage/uploadFile/client.uploadFile.html</a></p>
<h2 id="5-3，给商品列表加商品图片"><a href="#5-3，给商品列表加商品图片" class="headerlink" title="5-3，给商品列表加商品图片"></a>5-3，给商品列表加商品图片</h2><p>我们既然已经学完图片上传功能了，那么我们就可以改造下我们之前的商品列表了，给我们的商品列表添加商品图片。<br><img src="https://img-blog.csdnimg.cn/20210202172602566.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="5-4，上传视频到云存储"><a href="#5-4，上传视频到云存储" class="headerlink" title="5-4，上传视频到云存储"></a>5-4，上传视频到云存储</h2><p>上传视频之前同样需要先选择视频，选择视频的代码如下<br><img src="https://img-blog.csdnimg.cn/20210201163512755.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>对应的官方文档如下：<a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/api/media/video/wx.chooseVideo.html">https://developers.weixin.qq.com/miniprogram/dev/api/media/video/wx.chooseVideo.html</a><br><img src="https://img-blog.csdnimg.cn/20210201163541479.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>选择好视频以后，同样是调用文件上传api，因为视频也是一个文件。<br><img src="https://img-blog.csdnimg.cn/2021020116363179.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="5-5，上传word，excel文件到云存储"><a href="#5-5，上传word，excel文件到云存储" class="headerlink" title="5-5，上传word，excel文件到云存储"></a>5-5，上传word，excel文件到云存储</h2><h3 id="5-5-1，上传之前先选择文件"><a href="#5-5-1，上传之前先选择文件" class="headerlink" title="5-5-1，上传之前先选择文件"></a>5-5-1，上传之前先选择文件</h3><p>选择文件的时候记得把type设置为file<br><img src="https://img-blog.csdnimg.cn/20210201163838790.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>对应的官方文档：<a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/api/media/image/wx.chooseMessageFile.html">https://developers.weixin.qq.com/miniprogram/dev/api/media/image/wx.chooseMessageFile.html</a></p>
<ul>
<li>这里有一点需要注意<br>在电脑模拟器上是选择电脑上的文件，在手机上运行小程序进行选择文件时是选择你聊天记录里的文件。</li>
</ul>
<h3 id="5-5-2，上传文件"><a href="#5-5-2，上传文件" class="headerlink" title="5-5-2，上传文件"></a>5-5-2，上传文件</h3><p>在上面选择好文件以后，我们还是要调用uploadFile进行文件上传<br><img src="https://img-blog.csdnimg.cn/20210201164637337.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="5-6，下载文件"><a href="#5-6，下载文件" class="headerlink" title="5-6，下载文件"></a>5-6，下载文件</h2><p>使用wx.cloud.downloadFile下载文件<br><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/wxcloud/reference-client-api/storage/downloadFile.html">https://developers.weixin.qq.com/miniprogram/dev/wxcloud/reference-client-api/storage/downloadFile.html</a><br><img src="https://img-blog.csdnimg.cn/20210205163358308.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="5-7，下载并打开word，excel，pdf"><a href="#5-7，下载并打开word，excel，pdf" class="headerlink" title="5-7，下载并打开word，excel，pdf"></a>5-7，下载并打开word，excel，pdf</h2><p>使用wx.openDocument打开文件<br><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/api/file/wx.openDocument.html">https://developers.weixin.qq.com/miniprogram/dev/api/file/wx.openDocument.html</a><br><img src="https://img-blog.csdnimg.cn/20210205163603197.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<h1 id="六，列表的下拉刷新"><a href="#六，列表的下拉刷新" class="headerlink" title="六，列表的下拉刷新"></a>六，列表的下拉刷新</h1><h2 id="6-1，开启页面下拉刷新"><a href="#6-1，开启页面下拉刷新" class="headerlink" title="6-1，开启页面下拉刷新"></a>6-1，开启页面下拉刷新</h2><p>我们需要在app.json获取页面对应的json里设置enablePullDownRefresh属性为true来开启下拉刷新。</p>
<p><img src="https://img-blog.csdnimg.cn/20210205170856209.png" alt="img"><br><img src="https://img-blog.csdnimg.cn/20210205171621417.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>由于我们的刷新动画默认是白色圆点，所以还要在json里设置页面背景色才可以看到动画。<br><img src="https://img-blog.csdnimg.cn/20210205174537120.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="6-2，在Page的onPullDownRefresh里监听刷新"><a href="#6-2，在Page的onPullDownRefresh里监听刷新" class="headerlink" title="6-2，在Page的onPullDownRefresh里监听刷新"></a>6-2，在Page的onPullDownRefresh里监听刷新</h2><p><img src="https://img-blog.csdnimg.cn/20210205171045580.png" alt="img"><br>在page里的onPullDownRefresh方法里监听下拉刷新<br><img src="https://img-blog.csdnimg.cn/20210205171941928.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="6-3，用户下拉刷新时请求最新数据"><a href="#6-3，用户下拉刷新时请求最新数据" class="headerlink" title="6-3，用户下拉刷新时请求最新数据"></a>6-3，用户下拉刷新时请求最新数据</h2><p><img src="https://img-blog.csdnimg.cn/2021020517250836.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="6-4，数据请求成功后停止刷新"><a href="#6-4，数据请求成功后停止刷新" class="headerlink" title="6-4，数据请求成功后停止刷新"></a>6-4，数据请求成功后停止刷新</h2><p>我们在下拉刷新时，刷新动画一般很久才结束，正常情况下应该是数据请求成功后就结束刷新动画。所以我们通过wx.stopPullDownRefresh()方法来结束刷新动画。<br>官方文档：<a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/api/ui/pull-down-refresh/wx.startPullDownRefresh.html">https://developers.weixin.qq.com/miniprogram/dev/api/ui/pull-down-refresh/wx.startPullDownRefresh.html</a><br><img src="https://img-blog.csdnimg.cn/20210205174805866.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>代码示例如下<br><img src="https://img-blog.csdnimg.cn/20210205175925121.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<h1 id="七，列表的分页加载"><a href="#七，列表的分页加载" class="headerlink" title="七，列表的分页加载"></a>七，列表的分页加载</h1><h2 id="7-1，小程序数据库每次最多20条"><a href="#7-1，小程序数据库每次最多20条" class="headerlink" title="7-1，小程序数据库每次最多20条"></a>7-1，小程序数据库每次最多20条</h2><p>小程序数据库api和云函数调用数据的限制<br>小程序端直接调用云数据库时，每次最多可以获取20条，云函数里调用云数据库时每次最多获取100条。所以我们数据多的时候要做分页加载。</p>
<h2 id="7-2，分页加载的核心方法"><a href="#7-2，分页加载的核心方法" class="headerlink" title="7-2，分页加载的核心方法"></a>7-2，分页加载的核心方法</h2><p>我们做分页加载时，主要用到了skip和limit方法，对应的官方文档如下</p>
<ul>
<li>skip：每页加载多少条<br><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/wxcloud/reference-sdk-api/database/collection/Collection.skip.html">https://developers.weixin.qq.com/miniprogram/dev/wxcloud/reference-sdk-api/database/collection/Collection.skip.html</a></li>
<li>limit: 加载第几页的数据<a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/wxcloud/reference-sdk-api/database/collection/Collection.limit.html">https://developers.weixin.qq.com/miniprogram/dev/wxcloud/reference-sdk-api/database/collection/Collection.limit.html</a></li>
</ul>
<p>其实这个skip和limit我在数据库的那一节有做初步讲解，这一节我们就借助具体分页加载的案例来做综合讲解</p>
<h2 id="7-3，导入108条数据"><a href="#7-3，导入108条数据" class="headerlink" title="7-3，导入108条数据"></a>7-3，导入108条数据</h2><h3 id="7-3-1，下载数据源"><a href="#7-3-1，下载数据源" class="headerlink" title="7-3-1，下载数据源"></a>7-3-1，下载数据源</h3><p>去数据库里创建108条数据即可。</p>
<h3 id="7-3-2，导入到数据表"><a href="#7-3-2，导入到数据表" class="headerlink" title="7-3-2，导入到数据表"></a>7-3-2，导入到数据表</h3><p>我这里导入到num数据表，导入成功如下：<br><img src="https://img-blog.csdnimg.cn/2021022010395576.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="7-3-3，别忘记修改表权限"><a href="#7-3-3，别忘记修改表权限" class="headerlink" title="7-3-3，别忘记修改表权限"></a>7-3-3，别忘记修改表权限</h3><p>把数据表(集合)的权限改为所有用户可读，仅创建者可读写。<br><img src="https://img-blog.csdnimg.cn/20210220104538397.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="7-4，上拉加载更多监听"><a href="#7-4，上拉加载更多监听" class="headerlink" title="7-4，上拉加载更多监听"></a>7-4，上拉加载更多监听</h2><p>我们的列表滑动到最后一个数据时，会执行下面的方法<br><img src="https://img-blog.csdnimg.cn/20210222160533139.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>所以我们的分页加载要在onReachBottom里做。</p>
<h2 id="7-5，数据库分页加载代码实现"><a href="#7-5，数据库分页加载代码实现" class="headerlink" title="7-5，数据库分页加载代码实现"></a>7-5，数据库分页加载代码实现</h2><p>直接调用数据库每次最多只能加载20条数据<br><img src="https://img-blog.csdnimg.cn/20210222161602873.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>wxml里只做简单的列表数据显示就行了<br><img src="https://img-blog.csdnimg.cn/20210222161633284.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>wxss做个简单的样式<br><img src="https://img-blog.csdnimg.cn/2021022216165113.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>对应的效果如下<br><img src="https://img-blog.csdnimg.cn/2021022216171223.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="7-5-1，没有更多数据时的友好提示"><a href="#7-5-1，没有更多数据时的友好提示" class="headerlink" title="7-5-1，没有更多数据时的友好提示"></a>7-5-1，没有更多数据时的友好提示</h3><p><img src="https://img-blog.csdnimg.cn/20210224163137345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210224162947430.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="7-5-2，加载中和加载完成的友好提示"><a href="#7-5-2，加载中和加载完成的友好提示" class="headerlink" title="7-5-2，加载中和加载完成的友好提示"></a>7-5-2，加载中和加载完成的友好提示</h3><ul>
<li>加载中</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wx.showLoading(&#123;</span><br><span class="line">   title: &#x27;加载中...&#x27;,</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>



<ul>
<li>隐藏加载中</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wx.hideLoading()</span><br></pre></td></tr></table></figure>



<p><img src="https://img-blog.csdnimg.cn/20210224163236298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="7-6-通过云函数实现分页加载"><a href="#7-6-通过云函数实现分页加载" class="headerlink" title="7-6,通过云函数实现分页加载"></a>7-6,通过云函数实现分页加载</h2><p>通过云函数调用数据库，每次最多可以加载100条数据.</p>
<ul>
<li>如果每页20条以内，不建议用云函数</li>
<li>如果分页的时候，每页大于20条，就用云函数。<br><img src="https://img-blog.csdnimg.cn/20210224164952168.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></li>
</ul>
<h1 id="八，搜索功能"><a href="#八，搜索功能" class="headerlink" title="八，搜索功能"></a>八，搜索功能</h1><p>今天来给大家讲讲小程序的搜索功能。我这里后台数据库用的是小程序云开发的云数据库。所以我们搜索的时候就要借助云开发来实现。</p>
<p>注意：我们存数据的数据表(集合)要把权限改成如下所示。<br><img src="https://img-blog.csdnimg.cn/4e3ba9d1854f4b569cb2ebacf71ca29b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA57yW56iL5bCP55-z5aS0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<h2 id="8-1，需求"><a href="#8-1，需求" class="headerlink" title="8-1，需求"></a>8-1，需求</h2><p>比如我这里有如下的一些数据<br>可以自己一个个添加数据</p>
<p>{</p>
<p>“_id”:”xxxxxxxxxxs1212131321”,</p>
<p>“title”:’石头’,</p>
<p>“desc”:’ghd1d’</p>
<p>}，</p>
<p>{</p>
<p>“_id”:”xxxxxxxxxxs121aAASs1321”,</p>
<p>“title”:’黑石头’,</p>
<p>“desc”:’ghd1d’</p>
<p>}………</p>
<p>我们想实现如下搜索需求</p>
<ul>
<li>1，搜索标题(title)包含‘小石头’的数据</li>
<li>2，搜索标题(title)或者描述(desc)包含‘小石头’的数据</li>
<li>3，搜索标题(title)描述(desc)都包含‘小石头’的数据</li>
</ul>
<p>我们知道数据库查询的时候有个where语句，但是where语句是查询某个字段全部包含你输入的内容时才可以，所以单纯用where语句来做搜索的话，结果太单一。所以我们今天就来学习下模糊搜索功能的实现。我们以上面三个需求为例，来一个个讲解。</p>
<h2 id="8-2，实现原理"><a href="#8-2，实现原理" class="headerlink" title="8-2，实现原理"></a>8-2，实现原理</h2><p>我们做模糊搜索的时候，其实就是查询某个字段里是否包含我们的搜索词。而模糊搜索需要借助RegExp，来看看RegExp是什么。<br><img src="https://img-blog.csdnimg.cn/20210207214411585.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>官方文档：<a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/wxcloud/reference-sdk-api/database/Database.RegExp.html">https://developers.weixin.qq.com/miniprogram/dev/wxcloud/reference-sdk-api/database/Database.RegExp.html</a></p>
<ul>
<li>再来看看官方示例<br><img src="https://img-blog.csdnimg.cn/2021020721445170.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>可能看官方示例会有点糊涂，那么我们接下来就结合具体代码来给大家做下讲解。</li>
</ul>
<h2 id="8-3，模糊搜索的代码实现"><a href="#8-3，模糊搜索的代码实现" class="headerlink" title="8-3，模糊搜索的代码实现"></a>8-3，模糊搜索的代码实现</h2><h3 id="8-3-1，模糊搜索单个字段"><a href="#8-3-1，模糊搜索单个字段" class="headerlink" title="8-3-1，模糊搜索单个字段"></a>8-3-1，模糊搜索单个字段</h3><ul>
<li>需求：搜索标题(title)包含‘小石头’的数据</li>
</ul>
<p>代码如下<br><img src="https://img-blog.csdnimg.cn/20210207215202954.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>可以看到我们成功的查询到了标题里包含‘小石头的数据’</p>
<h3 id="8-3-2，模糊搜索多个字段（满足一个即可）"><a href="#8-3-2，模糊搜索多个字段（满足一个即可）" class="headerlink" title="8-3-2，模糊搜索多个字段（满足一个即可）"></a>8-3-2，模糊搜索多个字段（满足一个即可）</h3><ul>
<li>需求：搜索标题(title)或者描述(desc)包含‘小石头’的数据</li>
</ul>
<p>由于我们要查询多个字段，所以我们这里用到了command高级操作符里的or<br><img src="https://img-blog.csdnimg.cn/20210207215716587.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>代码如下：<br><img src="https://img-blog.csdnimg.cn/20210207220123112.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="8-3-3，模糊搜索多个字段（要同时满足）"><a href="#8-3-3，模糊搜索多个字段（要同时满足）" class="headerlink" title="8-3-3，模糊搜索多个字段（要同时满足）"></a>8-3-3，模糊搜索多个字段（要同时满足）</h3><ul>
<li>需求：搜索标题(title)描述(desc)都包含‘小石头’的数据</li>
</ul>
<p>由于我们要查询多个字段，所以我们这里用到了command高级操作符里的and<br><img src="https://img-blog.csdnimg.cn/20210207221006673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>代码如下：<br><img src="https://img-blog.csdnimg.cn/20210207220906802.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="8-4，源码"><a href="#8-4，源码" class="headerlink" title="8-4，源码"></a>8-4，源码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//简单起见就把搜索词写死，正常应该用户输入的</span><br><span class="line">let searchKey = &#x27;小石头&#x27;</span><br><span class="line">let db = wx.cloud.database()</span><br><span class="line">let _ = db.command</span><br><span class="line"></span><br><span class="line">db.collection(&#x27;news&#x27;)</span><br><span class="line">  .where(_.or([</span><br><span class="line">    &#123;//标题</span><br><span class="line">      title: db.RegExp(&#123; //使用正则查询，实现对搜索的模糊查询</span><br><span class="line">        regexp: searchKey,</span><br><span class="line">        options: &#x27;i&#x27;, //大小写不区分</span><br><span class="line">      &#125;),</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;//描述</span><br><span class="line">      desc: db.RegExp(&#123;</span><br><span class="line">        regexp: searchKey,</span><br><span class="line">        options: &#x27;i&#x27;,</span><br><span class="line">      &#125;),</span><br><span class="line">    &#125;</span><br><span class="line">  ])).get()</span><br><span class="line">  .then(res =&gt; &#123;</span><br><span class="line">    console.log(&#x27;查询成功&#x27;, res)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(res =&gt; &#123;</span><br><span class="line">    console.log(&#x27;查询失败&#x27;, res)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>



<h1 id="九，云开发实现登陆注册功能"><a href="#九，云开发实现登陆注册功能" class="headerlink" title="九，云开发实现登陆注册功能"></a>九，云开发实现登陆注册功能</h1><h2 id="9-1，注册页"><a href="#9-1，注册页" class="headerlink" title="9-1，	注册页"></a>9-1，	注册页</h2><p>注册页主要用到了input组件获取用户输入，button组件实现注册功能，注册主要是把账号名和密码添加到云开发数据库</p>
<h2 id="9-2，登陆页"><a href="#9-2，登陆页" class="headerlink" title="9-2，	登陆页"></a>9-2，	登陆页</h2><p>登陆主要是获取用户输入的账号和密码，然后从数据库里读取相应的数据，做账号和密码的比对，如果账号和密码都一样，就可以直接登陆成功</p>
<h2 id="9-3，登陆成功跳转到首页"><a href="#9-3，登陆成功跳转到首页" class="headerlink" title="9-3，	登陆成功跳转到首页"></a>9-3，	登陆成功跳转到首页</h2><p>登陆成功以后，会调整到首页</p>
<h2 id="9-4，保存登陆状态"><a href="#9-4，保存登陆状态" class="headerlink" title="9-4，	保存登陆状态"></a>9-4，	保存登陆状态</h2><p>我们通常做登陆时，用户登陆成功后我们需要帮用户保存登陆状态，要不然用户下次再进入应用时还要重新登陆。所以我们要做下用户登陆状态的保存</p>
<h1 id="十，云开发实现点赞收藏评论功能"><a href="#十，云开发实现点赞收藏评论功能" class="headerlink" title="十，云开发实现点赞收藏评论功能"></a>十，云开发实现点赞收藏评论功能</h1><h2 id="10-1，常用图标获取网站"><a href="#10-1，常用图标获取网站" class="headerlink" title="10-1，	常用图标获取网站"></a>10-1，	常用图标获取网站</h2><p>这里用了一个阿里巴巴矢量图库：<a target="_blank" rel="noopener" href="https://www.iconfont.cn/">https://www.iconfont.cn</a></p>
<h2 id="10-2，云函数里初始化云开发环境"><a href="#10-2，云函数里初始化云开发环境" class="headerlink" title="10-2，	云函数里初始化云开发环境"></a>10-2，	云函数里初始化云开发环境</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cloud.init(&#123;</span><br><span class="line">env: cloud.DYNAMIC_CURRENT_ENV</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h1 id="十一，评论功能的简单实现"><a href="#十一，评论功能的简单实现" class="headerlink" title="十一，评论功能的简单实现"></a>十一，评论功能的简单实现</h1><h1 id="十二，CMS网页版管理后台"><a href="#十二，CMS网页版管理后台" class="headerlink" title="十二，CMS网页版管理后台"></a>十二，CMS网页版管理后台</h1><h2 id="12-1，开通cms的准备工作"><a href="#12-1，开通cms的准备工作" class="headerlink" title="12-1，开通cms的准备工作"></a>12-1，开通cms的准备工作</h2><p>如下图所示，直接点击开通内容管理(CMS)即可<br><img src="https://img-blog.csdnimg.cn/20210210113912477.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>开通cms需要你云开发里使用按量付费，如果你是第一次开通云开发，记得做如下选择。<br><img src="https://img-blog.csdnimg.cn/20210310190751658.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>如果你已经开通过云开发，记得把付费模式改为按量付费。如果你一开始云开发不是按量付费的模式。</p>
<p>点击完开通以后，会有如下弹窗，直接点击确定即可。不要被付费吓着，官方每月会送我们一定的免费额度的。学习得话基本上够用了。<br><img src="https://img-blog.csdnimg.cn/20210210114114135.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>上面点完确定后，我们只是开启了按量付费功能，因为cms得使用必须要开通按量付费才可以得。所以还要再点一次开通。如下图<br><img src="https://img-blog.csdnimg.cn/20210210114330998.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>点完开通后，会有如下弹窗，直接点击下一步即可。<br><img src="https://img-blog.csdnimg.cn/20210210114443541.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>然后我们需要设置登录内容管理后台得账号和密码，然后点击确定即可<br><img src="https://img-blog.csdnimg.cn/20210210114541730.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>然后我们就等待内容管理功能得开通了，需要等几分钟。<br><img src="https://img-blog.csdnimg.cn/20210210114640668.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>开通成功以后，我们就可以通过下面这个地址进入管理后台了。<br><img src="https://img-blog.csdnimg.cn/20210210133616295.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>后面我们统一称内容管理为cms</p>
<h2 id="12-2，注意事项"><a href="#12-2，注意事项" class="headerlink" title="12-2，注意事项"></a>12-2，注意事项</h2><ul>
<li>一个云开发环境对应一个内容管理(cms)</li>
<li>cms开通会存在开通失败的情况，如果开通失败了，就用新的云开发环境去开通，如果新的云开发环境还是不行的话，那就只能重新去注册一个新的小程序了。一个小程序是可以开通两个云开发环境的。</li>
</ul>
<h2 id="12-3，登录Cms可视化管理后台"><a href="#12-3，登录Cms可视化管理后台" class="headerlink" title="12-3，登录Cms可视化管理后台"></a>12-3，登录Cms可视化管理后台</h2><p>上面开通好以后，就可以通过后台地址登录管理后台了。如下<br><img src="https://img-blog.csdnimg.cn/20210210133522942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="12-4，在cms里创建后台项目"><a href="#12-4，在cms里创建后台项目" class="headerlink" title="12-4，在cms里创建后台项目"></a>12-4，在cms里创建后台项目</h2><p>第一次登录，我们还需要创建一个项目<br><img src="https://img-blog.csdnimg.cn/20210210133725671.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>自己输入项目名和项目id即可<br><img src="https://img-blog.csdnimg.cn/20210210133904722.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>然后点击进入刚刚创建的项目<br><img src="https://img-blog.csdnimg.cn/9f7b0fb259104355954fa44c817029c7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA57yW56iL5bCP55-z5aS0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>到这里我们的cmd可视化网页管理后台就创建好了</p>
<h2 id="12-5，内容模型"><a href="#12-5，内容模型" class="headerlink" title="12-5，内容模型"></a>12-5，内容模型</h2><p><img src="https://img-blog.csdnimg.cn/8382630149d541af89e4512c57914ce9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA57yW56iL5bCP55-z5aS0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<h2 id="12-6，数据类型"><a href="#12-6，数据类型" class="headerlink" title="12-6，数据类型"></a>12-6，数据类型</h2><p>我们往内容模型里添加数据类型的时候可以选择如下一些类型<br><img src="https://img-blog.csdnimg.cn/711bfdbb8474433ab0be987afe683f5c.png" alt="img"></p>
<h2 id="12-7，数据表-集合-管理"><a href="#12-7，数据表-集合-管理" class="headerlink" title="12-7，数据表(集合)管理"></a>12-7，数据表(集合)管理</h2><p>我们可以对上面创建好的内容模型(集合)进行可视化的管理，这也是cms的优点，可以让我们对数据库进行可视化的管理。<br><img src="https://img-blog.csdnimg.cn/2493b0597b2843929b0b89ece373f445.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA57yW56iL5bCP55-z5aS0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<h2 id="12-8，综合案例"><a href="#12-8，综合案例" class="headerlink" title="12-8，综合案例"></a>12-8，综合案例</h2><p>结合cms和云开发数据库，实现一个简单的新闻小程序，有如下功能点</p>
<ul>
<li>1，新闻列表</li>
<li>2，新闻详情</li>
<li>3，图文混排</li>
<li>4，富文本编辑</li>
<li>5，rich-text的学习</li>
</ul>
<p>rich-text官方文档：<br><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/component/rich-text.html">https://developers.weixin.qq.com/miniprogram/dev/component/rich-text.html</a></p>
<h1 id="云开发实战案例···》"><a href="#云开发实战案例···》" class="headerlink" title="云开发实战案例···》"></a>云开发实战案例···》</h1><h1 id="实战一，云开发实现订阅消息推送"><a href="#实战一，云开发实现订阅消息推送" class="headerlink" title="实战一，云开发实现订阅消息推送"></a>实战一，云开发实现订阅消息推送</h1><p>之前的通过formid发送模板消息推送，将在2020年1月10日下线，所以我们不得不使用订阅消息了。</p>
<p>我们先来看下订阅消息的官方简介。<br><img src="https://img-blog.csdnimg.cn/img_convert/b7db371aea0e724e54f6d94c279171ba.png" alt="img"><br>接下来我们就来借助云开发，来快速实现小程序消息推送的功能。</p>
<h2 id="1-获取模板-ID"><a href="#1-获取模板-ID" class="headerlink" title="1,获取模板 ID"></a>1,获取模板 ID</h2><p>这一步和我们之前的模板消息推送是一样的，也是先添加模板，然后拿到模板id<br><img src="https://img-blog.csdnimg.cn/img_convert/3a3cb57812e875bc3b70c3425a5a900a.png" alt="img"><br>首先是开通订阅消息功能，很简单，如下图<br><img src="https://img-blog.csdnimg.cn/img_convert/b271655c0edb6ca4751da3d2c891bde0.png" alt="img"><br>由于长期性订阅消息，目前仅向政务民生、医疗、交通、金融、教育等线下公共服务开放，后期将逐步支持到其他线下公共服务业务。仅就线下公共服务这一点，长期性订阅消息就和大部分开发者无缘了。<br>所以我们这里只能以使用一次性订阅消息为例。<br><img src="https://img-blog.csdnimg.cn/img_convert/421d178fcfee1bfccd5ae0839d76a7c6.png" alt="img"><br>如上图，我们从公共模板库里选择一个一次性订阅的模板。然后编辑模板如下图<br><img src="https://img-blog.csdnimg.cn/img_convert/a0f65d36b5d27fd329c14d2df34cde00.png" alt="img"><br>下图就是我们添加好的模板，下图的模板id就是我们需要的。<br><img src="https://img-blog.csdnimg.cn/img_convert/8bd49bd2ddc542f0c4484aa7db73b6f7.png" alt="img"></p>
<h2 id="2-请求用户授权"><a href="#2-请求用户授权" class="headerlink" title="2,请求用户授权"></a>2,请求用户授权</h2><p>我们做订阅消息授权时，只能是用户点击或者支付完成后才可以调起来授权弹窗，官方是这么要求的：<br><img src="https://img-blog.csdnimg.cn/img_convert/20dca555457350c4c5d959e5d96e6c53.png" alt="img"><br>我们这里用到了wx.requestSubscribeMessage这个方法，来获取用户的授权。</p>
<ul>
<li>1，编写index.wxml代码<br><img src="https://img-blog.csdnimg.cn/img_convert/05dade190a567e04dd9c37315a685697.png" alt="img"></li>
<li>2，编写index.js代码,实现点击获取授权<br><img src="https://img-blog.csdnimg.cn/img_convert/41ce63de1a026e53ab47208cc39f2134.png" alt="img"><br>这一步tmplIds里的一串字符，就是我们自己添加的模板id</li>
<li>3，点击按钮运行效果如下<br>开发者工具模拟器上点击授权弹窗是这样的：<br><img src="https://img-blog.csdnimg.cn/img_convert/7a8f3304b2ff6971069831bb2524cca1.png" alt="img"><br>手机上的授权弹窗是这样的：<br><img src="https://img-blog.csdnimg.cn/img_convert/67407a9080f668313efb41eac09cdc33.png" alt="img"><br>可以看到，这里显示的就是我们添加的 ‘上课提醒’的模板。<br>细心的同学可以看到， 真机上多了一个 ‘总是保持以上选择，不再询问’<br>其实，你自己仔细多品一些。也能明天，我们正常订阅消息授权时，用户允许的话，你只能推送一次消息。也就是用户允许一次，我们就可以推送一条消息给用户，并且这个允许不存在过期。所以我们可以让用户尽量多的点击允许，这样我们就可以尽量多的给用户发送消息了。</li>
</ul>
<p>这里用户允许后，我们就可以给用户推送消息了，接下来我们来借助云开发的云函数来实现消息推送功能。</p>
<h2 id="3-获取用户的opneid"><a href="#3-获取用户的opneid" class="headerlink" title="3,获取用户的opneid"></a>3,获取用户的opneid</h2><p>先来看官方爸爸是怎么说的。<br><img src="https://img-blog.csdnimg.cn/img_convert/482348d3ed75f4073d52a2a19725d022.png" alt="img"><br>可以看出官方提供了两种方式，我们这里使用云调用。说白了就是在云函数里调用推送功能。</p>
<ul>
<li>推送所需参数<br><img src="https://img-blog.csdnimg.cn/img_convert/b618346a4b113511dc583b2a223fc0de.png" alt="img"><br>可以看到我这里用来openapi功能，并且需要用到用户的opneid，关于openid的获取，我之前有写过文章，也录过视频的。文章的话，大家去翻下我历史的文章，视频的话，点击这个即可：<a target="_blank" rel="noopener" href="https://edu.csdn.net/course/play/26572/336253">《借助云函数获取用户openid》</a><br>这里的openid的获取我就不再详细讲解了，把对应云函数的代码给大家贴出来。<br><img src="https://img-blog.csdnimg.cn/img_convert/ea953e4aedb5e5290741cfe9341bc308.png" alt="img"><br>在使用云开发时，有几点需要注意的</li>
<li>1，需要在project.config.json里创建云函数目录如下图<br><img src="https://img-blog.csdnimg.cn/img_convert/c57726436bc359a7f0b451fed2134541.png" alt="img"></li>
<li>2，需要在app.js里初始化云开发环境<br><img src="https://img-blog.csdnimg.cn/img_convert/ffbc71638437f0ac2071d03040533069.png" alt="img"><br>至于云开发的环境id从哪里拿，我视频里也讲过很多遍了，直接去看我视频或者翻看我历史文章即可。</li>
</ul>
<h2 id="4-用云函数实现消息推送"><a href="#4-用云函数实现消息推送" class="headerlink" title="4,用云函数实现消息推送"></a>4,用云函数实现消息推送</h2><p>我们只需要创建一个云函数如下，然后填入用户的openid，要跳转的小程序页面链接，模板内容，模板id即可。通常这些数据都应该传进来，简单起见，我就把这里的模板内容写成固定的。<br><img src="https://img-blog.csdnimg.cn/img_convert/6ea360fbc3e9a0ac1c2e8c984383168b.png" alt="img"></p>
<p><strong>注意</strong>：我在编写上面的代码时，推送内容的key必须和小程序模板里的key保持一致，否则就会报如下错误。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/7744febaaa1b6995afb5142965868cca.png" alt="img"></p>
<ul>
<li>然后看下调用这个云函数的地方<br><img src="https://img-blog.csdnimg.cn/img_convert/e2f325a86fb00c41f0f2ffe8c9c7f837.png" alt="img"><br>如果用户没有授权，我们推送会报如下错误<br><img src="https://img-blog.csdnimg.cn/img_convert/83e90947b16a013ffcab009e135f4397.png" alt="img"><br>如果用户授权过，我们就可以成功推送了，推送后的打印日志如下<br><img src="https://img-blog.csdnimg.cn/img_convert/fd154f7403927c3ef6ccb24b5ab82c76.png" alt="img"><br>还记得我们真机上的授权吗，如果用户只是点击了允许，没有选择一直允许，那我我们在推送成功一次后，如果再次推送，就需要用户重新授权。否则，还是会报这个错误的<br><img src="https://img-blog.csdnimg.cn/img_convert/7e05bc2ef9423835273e59a435c6ca34.png" alt="img"><br>所以我们用户点击一次允许，我们就可以推送一次消息，比如，我点击了4次允许那么我就可以成功的推送4次<br><img src="https://img-blog.csdnimg.cn/img_convert/48161ca1040adf3b859009c6c65a304a.png" alt="img"></li>
</ul>
<h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/a3110cee08ea827cdd438fb164050d41.png" alt="img"></p>
<ul>
<li>index.wxml</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;button bindtap=&quot;shouquan&quot; type=&#x27;primary&#x27;&gt;获取订阅消息授权&lt;/button&gt;</span><br><span class="line">&lt;button bindtap=&quot;getOpenid&quot;&gt;获取用户的openid并推送消息&lt;/button&gt;</span><br></pre></td></tr></table></figure>



<ul>
<li>index.js</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  //获取授权的点击事件</span><br><span class="line">  shouquan() &#123;</span><br><span class="line">    wx.requestSubscribeMessage(&#123;</span><br><span class="line">      tmplIds: [&#x27;CFeSWarQLMPyPjwmiy6AV4eB-IZcipu48V8bFLkBzTU&#x27;], //这里填入我们生成的模板id</span><br><span class="line">      success(res) &#123;</span><br><span class="line">        console.log(&#x27;授权成功&#x27;, res)</span><br><span class="line">      &#125;,</span><br><span class="line">      fail(res) &#123;</span><br><span class="line">        console.log(&#x27;授权失败&#x27;, res)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  //获取用户的openid</span><br><span class="line">  getOpenid() &#123;</span><br><span class="line">    wx.cloud.callFunction(&#123;</span><br><span class="line">      name: &quot;getopenid&quot;</span><br><span class="line">    &#125;).then(res =&gt; &#123;</span><br><span class="line">      let openid = res.result.openid</span><br><span class="line">      console.log(&quot;获取openid成功&quot;, openid)</span><br><span class="line">      this.send(openid)</span><br><span class="line">    &#125;).catch(res =&gt; &#123;</span><br><span class="line">      console.log(&quot;获取openid失败&quot;, res)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  //发送模板消息到指定用户,推送之前要先获取用户的openid</span><br><span class="line">  send(openid) &#123;</span><br><span class="line">    wx.cloud.callFunction(&#123;</span><br><span class="line">      name: &quot;sendMsg&quot;,</span><br><span class="line">      data: &#123;</span><br><span class="line">        openid: openid</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).then(res =&gt; &#123;</span><br><span class="line">      console.log(&quot;推送消息成功&quot;, res)</span><br><span class="line">    &#125;).catch(res =&gt; &#123;</span><br><span class="line">      console.log(&quot;推送消息失败&quot;, res)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<ul>
<li>推送对应的云函数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">const cloud = require(&#x27;wx-server-sdk&#x27;)</span><br><span class="line">cloud.init()</span><br><span class="line">exports.main = async(event, context) =&gt; &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    const result = await cloud.openapi.subscribeMessage.send(&#123;</span><br><span class="line">      touser: event.openid, //要推送给那个用户</span><br><span class="line">      page: &#x27;pages/index/index&#x27;, //要跳转到那个小程序页面</span><br><span class="line">      data: &#123;//推送的内容</span><br><span class="line">        thing1: &#123;</span><br><span class="line">          value: &#x27;小程序入门课程&#x27;</span><br><span class="line">        &#125;,</span><br><span class="line">        thing6: &#123;</span><br><span class="line">          value: &#x27;杭州浙江大学&#x27;</span><br><span class="line">        &#125;,</span><br><span class="line">        thing7: &#123;</span><br><span class="line">          value: &#x27;第一章第一节&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      templateId: &#x27;CFeSWarQLMPyPjwmiy6AV4eB-IZcipu48V8bFLkBzTU&#x27; //模板id</span><br><span class="line">    &#125;)</span><br><span class="line">    console.log(result)</span><br><span class="line">    return result</span><br><span class="line">  &#125; catch (err) &#123;</span><br><span class="line">    console.log(err)</span><br><span class="line">    return err</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>注意</strong>：授权一次，只能发送一条消息。</p>
<h2 id="5-发送订阅消息给多个用户"><a href="#5-发送订阅消息给多个用户" class="headerlink" title="5,发送订阅消息给多个用户"></a>5,发送订阅消息给多个用户</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//发送订阅消息给多个用户</span><br><span class="line">  sendAll() &#123;</span><br><span class="line">    if (name == null || name == &#x27;&#x27;) &#123;</span><br><span class="line">      wx.showToast(&#123;</span><br><span class="line">        icon: &quot;none&quot;,</span><br><span class="line">        title: &#x27;请输入课程名&#x27;,</span><br><span class="line">      &#125;)</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">    let users = [</span><br><span class="line">      &quot;oc4sa0Vp_s65LEItm4JSWT5WFQds&quot;,</span><br><span class="line">      &quot;oc4sa0dZ-pSCu95djiLCt7jo97bY&quot;</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    users.forEach(item =&gt; &#123;</span><br><span class="line">      console.log(&quot;for循环&quot;, item)</span><br><span class="line">      this.sendFun(item, name)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  //封装的方式方法</span><br><span class="line">  sendFun(openid, name) &#123;</span><br><span class="line">    wx.cloud.callFunction(&#123;</span><br><span class="line">      name: &quot;fasong&quot;,</span><br><span class="line">      data: &#123;</span><br><span class="line">        openid: openid,</span><br><span class="line">        name: name</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).then(res =&gt; &#123;</span><br><span class="line">      console.log(&quot;发送单条成功&quot;, res)</span><br><span class="line">    &#125;).catch(res =&gt; &#123;</span><br><span class="line">      console.log(&quot;发送单条失败&quot;, res)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h1 id="实战二，短信验证码"><a href="#实战二，短信验证码" class="headerlink" title="实战二，短信验证码"></a>实战二，短信验证码</h1><p>官方文档：<br><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/cloudbase/cloudbase.sendSms.html">https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/cloudbase/cloudbase.sendSms.html</a></p>
<p>进入官方文档一看，云开发给咱们开发者的福利还真不小。<br>不仅仅可以很方便的使用短信功能，还送了免费短信。</p>
<h2 id="1，使用云开发短信的条件"><a href="#1，使用云开发短信的条件" class="headerlink" title="1，使用云开发短信的条件"></a>1，使用云开发短信的条件</h2><p>这个前置条件很重要，条件不满足，你就没法使用云开发短信功能。</p>
<p>使用条件</p>
<ul>
<li>1，必须是企业小程序，目前个人小程序无法使用短信发送</li>
<li>2，必须开通静态网站功能（后面应该会逐步放开）</li>
<li>3，必须开通云开发（这个没得说，不开通云开发你还用啥云开发功能)</li>
</ul>
<h2 id="2，开通静态网站功能"><a href="#2，开通静态网站功能" class="headerlink" title="2，开通静态网站功能"></a>2，开通静态网站功能</h2><p>如果你不开通静态网站，直接调用短信发送，会报如下错误。<br><img src="https://img-blog.csdnimg.cn/20210109121558880.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>其实官方文档里也有给出这个错误。<br><img src="https://img-blog.csdnimg.cn/20210109121621602.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>那么我们就来开通静态网站功能。开通静态网站功能之前，必须开通云开发，配置好云开发的环境。</p>
<p>这里开通云开发我们借助小程序开发者工具来实现快速开通。</p>
<h3 id="2-1，注册小程序"><a href="#2-1，注册小程序" class="headerlink" title="2-1，注册小程序"></a>2-1，注册小程序</h3><h3 id="2-2，创建一个小程序项目"><a href="#2-2，创建一个小程序项目" class="headerlink" title="2-2，创建一个小程序项目"></a>2-2，创建一个小程序项目</h3><h3 id="2-3，开通云开发"><a href="#2-3，开通云开发" class="headerlink" title="2-3，开通云开发"></a>2-3，开通云开发</h3><h3 id="2-4，开通静态网站功能"><a href="#2-4，开通静态网站功能" class="headerlink" title="2-4，开通静态网站功能"></a>2-4，开通静态网站功能</h3><p><img src="https://img-blog.csdnimg.cn/20201211120905504.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>我们上面云开发开通好以后，就可以在这里快速开通静态网站了。<br><img src="https://img-blog.csdnimg.cn/20201211120927392.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>点击以后，直接点击开通即可<br><img src="https://img-blog.csdnimg.cn/20201211120948749.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>这时候开通有个条件<br><img src="https://img-blog.csdnimg.cn/20201211121007349.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>我们必须按照要求改变自己小程序的付费方式，把我们的付费方式改成按量付费即可。<br><img src="https://img-blog.csdnimg.cn/20201211121058390.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>这里不用担心，这里的按量付费，每月都有免费额度。这些额度我们开发学习基本上够用了<br><img src="https://img-blog.csdnimg.cn/20201211121137132.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br><img src="https://img-blog.csdnimg.cn/20201211121144821.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>这个时候我们的静态网站功能就开通成功了。<br><img src="https://img-blog.csdnimg.cn/20201211121157987.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>开通成功以后如下图。<br><img src="https://img-blog.csdnimg.cn/20201211121233312.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br><img src="https://img-blog.csdnimg.cn/20210109123050201.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="3，编写发送短信的云函数"><a href="#3，编写发送短信的云函数" class="headerlink" title="3，编写发送短信的云函数"></a>3，编写发送短信的云函数</h2><p>其实上面静态网站功能开通以后，我们不用上传网站资源，就可以直接来使用短信功能了。<br>下面我们就来使用云开发的云函数功能来做短信发送功能。<br>代码编写也很简单<br><img src="https://img-blog.csdnimg.cn/20210109123624813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>其实发送短信的代码很简单，就上面这几行。下面就来教大家如何编写这个云函数。</p>
<h3 id="3-1，初始化云开发环境id"><a href="#3-1，初始化云开发环境id" class="headerlink" title="3-1，初始化云开发环境id"></a>3-1，初始化云开发环境id</h3><p>新建一个和pages平级的目录cloud，用于存放云函数<br><img src="https://img-blog.csdnimg.cn/2021010912401458.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>然后在project.config.json里添加cloudfunctionRoot选项。<br><img src="https://img-blog.csdnimg.cn/20210109123846528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>然后对cloud选择当前环境<br><img src="https://img-blog.csdnimg.cn/20210109130001146.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>在app.js里配置环境变量<br><img src="https://img-blog.csdnimg.cn/20210109130043444.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>这个env环境id需要你去云开发控制台获取<br><img src="https://img-blog.csdnimg.cn/20210109130130467.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="3-2，创建云函数"><a href="#3-2，创建云函数" class="headerlink" title="3-2，创建云函数"></a>3-2，创建云函数</h3><p>右键cloud目录，新建Node.js云函数<br><img src="https://img-blog.csdnimg.cn/20210109130223400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>然后新建一个云函数，名字你可以自定随便定。我这里用sendSms<br><img src="https://img-blog.csdnimg.cn/20210109130321182.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="3-3，编写云函数"><a href="#3-3，编写云函数" class="headerlink" title="3-3，编写云函数"></a>3-3，编写云函数</h3><p><img src="https://img-blog.csdnimg.cn/20210109130405597.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>记得把env和接收短信的手机号换成自己的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const cloud = require(&#x27;wx-server-sdk&#x27;)</span><br><span class="line">cloud.init(&#123;</span><br><span class="line">  env: cloud.DYNAMIC_CURRENT_ENV</span><br><span class="line">&#125;)</span><br><span class="line">exports.main = async (event, context) =&gt; &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    const result = await cloud.openapi.cloudbase.sendSms(&#123;</span><br><span class="line">      env: &#x27;xiaoshitou-zfl2q&#x27;,</span><br><span class="line">      content: &#x27;编程小石头发布了新的能力&#x27;,</span><br><span class="line">      phoneNumberList: [</span><br><span class="line">        &quot;+86123123124121&quot;</span><br><span class="line">      ]</span><br><span class="line">    &#125;)</span><br><span class="line">    return result</span><br><span class="line">  &#125; catch (err) &#123;</span><br><span class="line">    return err</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-4，部署云函数"><a href="#3-4，部署云函数" class="headerlink" title="3-4，部署云函数"></a>3-4，部署云函数</h3><p>上面云函数编写好了，一定要记得部署下云函数。右键sendSms然后点击下面箭头所示的即可。<br><img src="https://img-blog.csdnimg.cn/20210109130811107.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>上传部署成功后，会有下面这样的提示<br><img src="https://img-blog.csdnimg.cn/20210109130925613.png" alt="img"></p>
<h2 id="4，调用云函数发送短信"><a href="#4，调用云函数发送短信" class="headerlink" title="4，调用云函数发送短信"></a>4，调用云函数发送短信</h2><p>我们上面云函数编写并部署成功以后，就可以来调用这个云函数，发送短信了。</p>
<h3 id="4-1，编写wxml文件"><a href="#4-1，编写wxml文件" class="headerlink" title="4-1，编写wxml文件"></a>4-1，编写wxml文件</h3><p>在wxml文件里写一个button按钮，编写一个bindtap点击事件<br><img src="https://img-blog.csdnimg.cn/20210109131049800.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="4-2，编写js文件"><a href="#4-2，编写js文件" class="headerlink" title="4-2，编写js文件"></a>4-2，编写js文件</h3><p>在js文件里实现上面button的点击事件，然后调用云函数<br><img src="https://img-blog.csdnimg.cn/2021010913122362.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>调用云函数时，一定要记得这里的name必须和你的云函数名一模一样。</p>
<h3 id="4-3，点击发送短信"><a href="#4-3，点击发送短信" class="headerlink" title="4-3，点击发送短信"></a>4-3，点击发送短信</h3><p>点击发送短信<br><img src="https://img-blog.csdnimg.cn/2021010913133224.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>点击发送 短信以后，可以看到日志里打印openapi.cloudbase.sendSms:ok<br>这就代表发送成功了。</p>
<h2 id="5，发送验证码短信"><a href="#5，发送验证码短信" class="headerlink" title="5，发送验证码短信"></a>5，发送验证码短信</h2><p>我们只需要获取用户输入的手机号，然后点击获取验证码，最后输入短信里接收到的验证码，进行验证即可。</p>
<h3 id="5-1，编写wxml"><a href="#5-1，编写wxml" class="headerlink" title="5-1，编写wxml"></a>5-1，编写wxml</h3><p>页面比较简单，就两个输入框和两个按钮<br><img src="https://img-blog.csdnimg.cn/20210109135120664.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="5-2，编写js"><a href="#5-2，编写js" class="headerlink" title="5-2，编写js"></a>5-2，编写js</h3><p>js里主要是获取用户输入的手机号，然后发送验证码，发送验证码调用云函数实现短信验证码发送功能。用户输入验证码以后进行校验即可。<br><img src="https://img-blog.csdnimg.cn/20210109135258919.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="5-3，发送短信验证码"><a href="#5-3，发送短信验证码" class="headerlink" title="5-3，发送短信验证码"></a>5-3，发送短信验证码</h3><p>用户输入手机号以后，点击发送，可以看到我们手机上收到了短信。</p>
<p>然后用户输入获取到的验证码，点击验证。</p>
<p>可以看到验证成功，验证成功以后后面的操作就可以自己定了，比如验证成功以后跳转到登录成功页。</p>
<p>到这里我们就实现了验证码发送功能了。</p>
<h3 id="5-4-生成随机验证码的方法"><a href="#5-4-生成随机验证码的方法" class="headerlink" title="5-4,生成随机验证码的方法"></a>5-4,生成随机验证码的方法</h3><h4 id="字母和数字混合"><a href="#字母和数字混合" class="headerlink" title="字母和数字混合"></a>字母和数字混合</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//获取随机验证码，n代表几位</span><br><span class="line">generateMixed(n) &#123;</span><br><span class="line">  let chars = [&#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;, &#x27;H&#x27;, &#x27;I&#x27;, &#x27;J&#x27;, &#x27;K&#x27;, &#x27;L&#x27;, &#x27;M&#x27;, &#x27;N&#x27;, &#x27;O&#x27;, &#x27;P&#x27;, &#x27;Q&#x27;, &#x27;R&#x27;, &#x27;S&#x27;, &#x27;T&#x27;, &#x27;U&#x27;, &#x27;V&#x27;, &#x27;W&#x27;, &#x27;X&#x27;, &#x27;Y&#x27;, &#x27;Z&#x27;];</span><br><span class="line">  let res = &quot;&quot;;</span><br><span class="line">  for (var i = 0; i &lt; n; i++) &#123;</span><br><span class="line">    var id = Math.ceil(Math.random() * 35);</span><br><span class="line">    res += chars[id];</span><br><span class="line">  &#125;</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="数字混合"><a href="#数字混合" class="headerlink" title="数字混合"></a>数字混合</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//获取随机验证码，n代表几位</span><br><span class="line">generateMixed(n) &#123;</span><br><span class="line">  let chars = [&#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;];</span><br><span class="line">  let res = &quot;&quot;;</span><br><span class="line">  for (var i = 0; i &lt; n; i++) &#123;</span><br><span class="line">    var id = Math.ceil(Math.random() * 9);</span><br><span class="line">    res += chars[id];</span><br><span class="line">  &#125;</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="实战三，群发短信"><a href="#实战三，群发短信" class="headerlink" title="实战三，群发短信"></a>实战三，群发短信</h1><p>我们上面给单个手机发送验证码的功能实现了，接下来就教大家如何群发短信。</p>
<p>官方文档：<br><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/cloudbase/cloudbase.sendSms.html">https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/cloudbase/cloudbase.sendSms.html</a></p>
<h4 id="使用云开发短信的条件"><a href="#使用云开发短信的条件" class="headerlink" title="使用云开发短信的条件"></a>使用云开发短信的条件</h4><p>这个前置条件很重要，条件不满足，你就没法使用云开发短信功能。</p>
<ul>
<li>1，必须是企业小程序，目前个人小程序无法使用短信发送</li>
<li>2，必须开通静态网站功能（后面应该会逐步放开）</li>
<li>3，必须开通云开发（这个没得说，不开通云开发你还用啥云开发功能啊）</li>
</ul>
<p>上面条件都满足以后，我们就可以来愉快的撸代码了。</p>
<h2 id="1，编写wxml页面"><a href="#1，编写wxml页面" class="headerlink" title="1，编写wxml页面"></a>1，编写wxml页面</h2><p>简单起见，我这里只定义一个输入手机号的输入框和一个button按钮<br><img src="https://img-blog.csdnimg.cn/20210110214701978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>对应的代码如下<br><img src="https://img-blog.csdnimg.cn/20210110214556726.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="2，获取用户输入的手机号"><a href="#2，获取用户输入的手机号" class="headerlink" title="2，获取用户输入的手机号"></a>2，获取用户输入的手机号</h2><p>我这里以*来分割手机号，如下图所示。<br><img src="https://img-blog.csdnimg.cn/20210110215200429.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>然后我们定义一个bindinput事件来获取用户输入的内容。<br><img src="https://img-blog.csdnimg.cn/20210110215350402.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>可以看到，我们成功的获取到了用户输入的手机号了。<br><img src="https://img-blog.csdnimg.cn/20210110215721299.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>但是官方文档里已经说明，我们群发短信的时候需要用到的是一组手机号，也就是说需要用数组来存放数据。但是我们这里是一个字符串。那么我们就要分割字符串成数组了。</p>
<h2 id="3，分割字符串成数组"><a href="#3，分割字符串成数组" class="headerlink" title="3，分割字符串成数组"></a>3，分割字符串成数组</h2><p>我们分割字符串用到的是字符串的split()方法<br><img src="https://img-blog.csdnimg.cn/20210110215844128.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>当然触发的时机，应该是在用户点击群发按钮的时候。那么我们就为群发按钮定义bindtap点击事件send<br><img src="https://img-blog.csdnimg.cn/20210110220111787.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>可以看到我们成功的把字符串分割成了数组。<br><img src="https://img-blog.csdnimg.cn/20210110220243381.png" alt="img"><br>但是我们数组里的手机号前面有个回车键，所以安全起见，我们在分割字符串之前，需要先把这回车键给剔除掉。</p>
<h2 id="4，去除字符串里的回车键"><a href="#4，去除字符串里的回车键" class="headerlink" title="4，去除字符串里的回车键"></a>4，去除字符串里的回车键</h2><p>去除字符串里的回车键语法如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字符串.replace(/[\r\n]/g, &quot;&quot;)</span><br></pre></td></tr></table></figure>



<p>可以看到我们只需要调用字符串.replace方法即可，后面括号里跟的是回车键对应的正则表达式。这里不需要记住，后面用的时候来我笔记这里复制就行了。<br><img src="https://img-blog.csdnimg.cn/20210110220615764.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>可以看到我们剔除回车键以后，再分割的字符串里就没有回车键了。</p>
<h2 id="5，遍历数组给手机号前面-86"><a href="#5，遍历数组给手机号前面-86" class="headerlink" title="5，遍历数组给手机号前面+86"></a>5，遍历数组给手机号前面+86</h2><p>如果你有仔细阅读官方文档，可以看到我们群发的手机号前面必须以+86开头。并且每次群发的手机号不能超过1000条。<br><img src="https://img-blog.csdnimg.cn/2021011022085622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>那么我们接下来就要遍历数组，给每个手机号前面都添加‘+86’了。<br>当然了这里有很多种方法来实现这一目的，我这里用一个for循环和一个map方法来分别实现下。<br><img src="https://img-blog.csdnimg.cn/20210110222029946.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>可以看出用map方法更简介一点。但是对于新手来说第二种方法可能不是很好理解。所以这里你用那种方法都可以，不做强制要求。</p>
<h3 id="5-1，通过for循环来实现"><a href="#5-1，通过for循环来实现" class="headerlink" title="5-1，通过for循环来实现"></a>5-1，通过for循环来实现</h3><p><img src="https://img-blog.csdnimg.cn/20210110222243469.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="5-2，通过map方法来实现"><a href="#5-2，通过map方法来实现" class="headerlink" title="5-2，通过map方法来实现"></a>5-2，通过map方法来实现</h3><p><img src="https://img-blog.csdnimg.cn/20210110221534846.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="6，编写群发短信的内容"><a href="#6，编写群发短信的内容" class="headerlink" title="6，编写群发短信的内容"></a>6，编写群发短信的内容</h2><p>那么我们接下来要做的就是实现群发功能了。我们这里要想成功的实现群发，需要两个元素</p>
<ul>
<li>要群发的短信内容</li>
<li>要群发的手机号</li>
</ul>
<p>关于手机号和群发内容都有要求<br><img src="https://img-blog.csdnimg.cn/20210110222505278.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>我们群发手机号这里已经符合要求了，接下来就是群发的内容了。群发内容最长不能超过60个字节，一个汉字通常2~3个字节。也就是说我们短信内容不能超过20个字，所以群发的短信一定要精细。用最少的字来吸引用户。</p>
<p>这里其实就是一个input来获取用户输入的内容就行了。我不再多讲，直接把代码贴出来。<br><img src="https://img-blog.csdnimg.cn/20210110223424454.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>在js里获取用户输入的短信内容<br><img src="https://img-blog.csdnimg.cn/2021011022370271.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>现在完事具备，只欠一个云函数了</p>
<h2 id="7，编写群发短信的云函数"><a href="#7，编写群发短信的云函数" class="headerlink" title="7，编写群发短信的云函数"></a>7，编写群发短信的云函数</h2><p>短信内容和群发的手机号都已经成功拿到了，我们接下来就要来编写群发的云函数了。<br><img src="https://img-blog.csdnimg.cn/20210110224043670.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>云函数其实我们短信验证码那一节基本上一样，区别就是</p>
<ul>
<li>短信验证传入的是：验证码+单个手机号</li>
<li>群发传入的是：短信内容+多个手机号</li>
</ul>
<p>云函数编辑好，记得重新部署下。</p>
<h2 id="8，调用云函数实现群发"><a href="#8，调用云函数实现群发" class="headerlink" title="8，调用云函数实现群发"></a>8，调用云函数实现群发</h2><p>上面云函数编辑好了，也部署好了，接下来就是要调用云函数实现短信群发了。<br><img src="https://img-blog.csdnimg.cn/20210110224541938.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>调用其实很简单。</p>
<h2 id="9，群发演示失败"><a href="#9，群发演示失败" class="headerlink" title="9，群发演示失败"></a>9，群发演示失败</h2><p>接下来我们就要验证自己的劳动成果了。如下，我发这样的内容给两个手机号。为什么是两个呢，我这里是学习，要节省短信条数。官方只送我们1000条。所以要省着点用。</p>
<p>其实群发两个手机号，和群发1000个没区别，只要群发两个成果，那么群发1000个也一样的。<br><img src="https://img-blog.csdnimg.cn/20210110224906123.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>辛辛苦苦编写好了，测试了下，居然报错<br><img src="https://img-blog.csdnimg.cn/20210110230354339.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>什么鬼，代码明明没有错误啊，程序员有时候就是莫名的自信。<br>官方给的发送成果返回字段如下<br><img src="https://img-blog.csdnimg.cn/20210110230510989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>发送返回结果如下<br><img src="https://img-blog.csdnimg.cn/20210110230547798.png" alt="img"><br>百思不得其解啊。不会真是代码写错了吧。。。。<br>翻译了一下报错信息。<br><img src="https://img-blog.csdnimg.cn/2021011023071456.png" alt="img"><br>发送时间限制，也没看到官方文档有说时间限制啊。后来又去官方文档翻来覆去，终于在一个角落里看到了这句话。</p>
<h2 id="10，群发演示成功"><a href="#10，群发演示成功" class="headerlink" title="10，群发演示成功"></a>10，群发演示成功</h2><p>终于等到了第二天8点47，下面我们把昨天的群发短信再演示一遍，看这次能不能成功。<br>先来看我们的日志<br><img src="https://img-blog.csdnimg.cn/20210111084934161.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-微信小程序"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/01/29/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"
    >微信小程序（零基础版）</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/01/29/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" class="article-date">
  <time datetime="2023-01-29T14:56:00.000Z" itemprop="datePublished">2023-01-29</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>说起微信小程序，渊源就长了，毕竟毕设做得就是微信小程序（基于微信小程序的体育馆自助预约与管理平台的设计与开发），前端微信小程序，后端微信云开发，后台CMS。也算是投入了一定的心思与时间叭。</p>
<p>微信小程序的开发与web端开发基本一致叭，但是微信小程序有更多封装好的API可以直接使用，需要投入时间学习开发文档。我觉得用微信小程序做一个普通的产品出来还是相对简单的。</p>
<h1 id="一、认识小程序"><a href="#一、认识小程序" class="headerlink" title="一、认识小程序"></a>一、认识小程序</h1><p>微信⼩程序，简称⼩程序，英⽂名 Mini Program Mini Program ，是⼀种不需要下载安装即可使⽤的应⽤，它实现 了应⽤“触⼿可及”的梦想，⽤⼾扫⼀扫或搜⼀下即可打开应⽤</p>
<h2 id="1-1、微信小程序的优势"><a href="#1-1、微信小程序的优势" class="headerlink" title="1-1、微信小程序的优势"></a>1-1、微信小程序的优势</h2><ul>
<li>1.微信有海量⽤⼾，⽽且粘性很⾼，在微信⾥开发产品更容易触达⽤⼾；</li>
<li>2.推⼴app或公众号的成本太⾼。</li>
<li>3.开发适配成本低。</li>
<li>4.容易⼩规模试错，然后快速迭代。</li>
<li>5.跨平台。</li>
</ul>
<p>通过小程序和app的使用步骤，更容易看出来<br><img src="https://pic.imgdb.cn/item/63d68611face21e9ef40613b.png"><br>可以看出小程序和app使用相比：免安装，免注册，免卸载。正如张小龙所说“随用随走”</p>
<h2 id="1-2、小程序发展前景"><a href="#1-2、小程序发展前景" class="headerlink" title="1-2、小程序发展前景"></a>1-2、小程序发展前景</h2><p>通过腾讯2020年财报可以看出，2019年上线小程序已经超过100万个，小程序日活也已经突破4亿<br><img src="https://pic.imgdb.cn/item/63d68621face21e9ef408567.png"><br>2019年小程序带动就业536万个，所以我们不管是学习小程序开发，还是学习小程序运营，都有很广的就业前景。<br><img src="https://pic.imgdb.cn/item/63d6862fface21e9ef40a74b.png"><br><img src="https://img-blog.csdnimg.cn/20200724120820817.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="1-3、小程序发展历史"><a href="#1-3、小程序发展历史" class="headerlink" title="1-3、小程序发展历史"></a>1-3、小程序发展历史</h2><ul>
<li>2016年1月11日，微信之父张小龙时隔多年的公开亮相，解读了微信的四大价值观。张小龙指出，越来越多产品通过公众号来做，因为这里开发、获取用户和传播成本更低。拆分出来的服务号并没有提供更好的服务，所以微信内部正在研究新的形态，叫「微信小程序」。</li>
<li>2016年9月21日，微信小程序正式开启内测。在微信生态下，触手可及、用完即走的微信小程序引起广泛关注。腾讯云正式上线微信小程序解决方案，提供微信小程序在云端服务器的技术方案。</li>
<li>2017年1月9日0点，万众瞩目的微信第一批微信小程序正式低调上线，用户可以体验到各种各样微信小程序提供的服务。</li>
<li>2017年12月28日，微信更新的 6.6.1 版本开放了小游戏，微信启动页面还重点推荐了小游戏「跳一跳」，你可以通过「微信小程序」找到已经玩过的小游戏。</li>
<li>2018年1月18日，微信提供了电子化的侵权投诉渠道，用户或者企业可以在微信公众平台以及微信客户端入口进行投诉。</li>
<li>2018年1月25日，微信团队在“微信公众平台”发布公告称，“从移动应用分享至微信的小程序页面，用户访问时支持打开来源应用。同时，为提升用户使用体验，开发者可以设置小程序菜单的颜色风格，并根据业务需求，对小程序菜单外的标题栏区域进行自定义。</li>
<li>2018年3月，微信正式宣布微信小程序广告组件启动内测，内容还包括第三方可以快速创建并认证小程序、新增小程序插件管理接口和更新基础能力，开发者可以通过微信小程序来赚取广告收入。除了公众号文中、朋友圈广告以及公众号底部的广告位都支持微信小程序落地页投放广告，微信小程序广告位也可以直达小程序。</li>
<li>2018年7月13日，微信小程序任务栏功能升级，新增“我的微信小程序”板块；而微信小程序原有的“星标”功能升级，可以将喜欢的小程序直接添加到“我的微信小程序”。</li>
<li>2018年8月10日，微信宣布，微信小程序后台数据分析及插件功能升级，开发者可查看已添加「我的微信小程序」的用户数。此外，2018年8月1日至12月31日期间，微信小程序（含小游戏）流量主的广告收入分成比例优化上调，单日广告流水10-100万区间的部分，开发者可获得的分成由原来流水的30%上调到50%，优质微信小程序流量主可获得更高收益。</li>
<li>2018年9月28日，微信“功能直达”正式开放，商家与用户的距离可以更“近”一步：用户微信搜一搜功能词，搜索页面将呈现相关服务的微信小程序，点击搜索结果，可直达微信小程序相关服务页面。</li>
<li>2019年8月9日，微信向开发者发布新能力公测与更新公告，微信 PC 版新版本中，支持打开聊天中分享的微信小程序。安装最新PC端测试版微信后，点击聊天中的微信小程序，便会弹出微信小程序浮窗。而在微信小程序右上角的操作选项中，可以进行“最小化”操作，让微信小程序像其他PC软件一样最小化，排列于Windows系统的任务栏中。</li>
</ul>
<h2 id="1-4、为什么学习小程序"><a href="#1-4、为什么学习小程序" class="headerlink" title="1-4、为什么学习小程序"></a>1-4、为什么学习小程序</h2><p>我们上面了解完小程序的优势和历史以后，就知道我们为什么要学习小程序了</p>
<ul>
<li>依赖微信生态</li>
<li>就业面广</li>
<li>上手快</li>
<li>学习完微信小程序以后，再去学习百度小程序，抖音小程序，支付宝小程序就很方便了。因为这些小程序api都很相似。</li>
<li>相对于Java，php，python而言，小程序更适合作为编程的入门语言</li>
<li>相对于传统前端开发，我们在学习小程序的同时就可以学习css，JavaScript的知识</li>
</ul>
<h2 id="1-5、微信小程序对创业者的优势"><a href="#1-5、微信小程序对创业者的优势" class="headerlink" title="1-5、微信小程序对创业者的优势"></a>1-5、微信小程序对创业者的优势</h2><ul>
<li>App开发的推广成本过高</li>
<li>移动互联网格局已定，用户需求被各路巨头把持，我们要想在移动互联网有一番作为，微信是不可避免的靠山</li>
<li>小程序能以最小的成本，最快的速度验证你的商业模式。</li>
</ul>
<h1 id="二、开发者工具"><a href="#二、开发者工具" class="headerlink" title="二、开发者工具"></a>二、开发者工具</h1><p>工欲善其事必先利其器，所以我们在开发小程序之前必须准备好一款适合自己的开发者工具，这里我给大家推荐官方开发者工具。原因有以下几点</p>
<ul>
<li>官方的所有更新，都会第一时间在官方开发者工具同步</li>
<li>有任何问题，可以直接反馈给官方</li>
<li>官方开发者工具更新迭代最及时</li>
<li>我们用官方开发者工具，使用一些官方功能最稳定。<br>下面就来教大家如何下载官方开发工具</li>
</ul>
<h2 id="2-1-官方开发者工具下载地址"><a href="#2-1-官方开发者工具下载地址" class="headerlink" title="2-1 官方开发者工具下载地址"></a>2-1 官方开发者工具下载地址</h2><p><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html">https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html</a><br>建议大家下载最新的稳定版本<br><img src="https://pic.imgdb.cn/item/63d68647face21e9ef40dfda.png"></p>
<p>然后点击自己电脑对应系统的版本下载即可。至于安装很方便，只需要双击安装包，不停的点下一步即可，安装完成以后的官方开发者工具长这样。<br><img src="https://pic.imgdb.cn/item/63d68662face21e9ef411cb8.png"></p>
<h2 id="2-2，认识微信开发者工具"><a href="#2-2，认识微信开发者工具" class="headerlink" title="2-2，认识微信开发者工具"></a>2-2，认识微信开发者工具</h2><p>我们安装好开发者工具以后，只需要双击打开即可。<br><img src="https://pic.imgdb.cn/item/63d68674face21e9ef414629.png"><br>通常我们第一次打开，会出现上图所示的，只需要用微信扫描即可登录开发者工具。扫码登录以后会出现下面这样的界面。<br><img src="https://pic.imgdb.cn/item/63d68682face21e9ef416448.png"></p>
<h1 id="三、创建属于自己的第一个小程序"><a href="#三、创建属于自己的第一个小程序" class="headerlink" title="三、创建属于自己的第一个小程序"></a>三、创建属于自己的第一个小程序</h1><p>上面第二步已经安装好开发者工具了，接下来就来教大家如何创建一个最简单的小程序</p>
<h2 id="3-1、在桌面上创建一个空白文件"><a href="#3-1、在桌面上创建一个空白文件" class="headerlink" title="3-1、在桌面上创建一个空白文件"></a>3-1、在桌面上创建一个空白文件</h2><p>名字可以随便取</p>
<p><img src="https://pic.imgdb.cn/item/63d686a4face21e9ef41ab10.png">·</p>
<h2 id="3-2、点击-号，创建小程序。"><a href="#3-2、点击-号，创建小程序。" class="headerlink" title="3-2、点击 + 号，创建小程序。"></a>3-2、点击 + 号，创建小程序。</h2><p><img src="https://pic.imgdb.cn/item/63d686baface21e9ef41daf2.png"></p>
<h2 id="3-3、小程序项目配置"><a href="#3-3、小程序项目配置" class="headerlink" title="3-3、小程序项目配置"></a>3-3、小程序项目配置</h2><p>这里需要注意下，小程序官方最新的开发者工具有了变化，所以你创建项目时如果不长下面这样。可以跳过这个图片，看下面新版的<br><img src="https://pic.imgdb.cn/item/63d686d4face21e9ef420eec.png"></p>
<p>新版的如下，多了一个模板选择，这里注意：要选择不使用模板。<br><img src="https://pic.imgdb.cn/item/63d686e3face21e9ef422e06.png"></p>
<p>配置好以后，点新建，即可创建属于自己的第一个小程序，然后创建会有一个过程，耐心等待即可。<br><img src="https://pic.imgdb.cn/item/63d686f4face21e9ef425072.png"></p>
<h2 id="3-4、熟悉开发者工具"><a href="#3-4、熟悉开发者工具" class="headerlink" title="3-4、熟悉开发者工具"></a>3-4、熟悉开发者工具</h2><p><img src="https://pic.imgdb.cn/item/63d686ffface21e9ef426734.png"></p>
<h2 id="3-6、小程序结构目录"><a href="#3-6、小程序结构目录" class="headerlink" title="3-6、小程序结构目录"></a>3-6、小程序结构目录</h2><p>下图是程序目录，每一个我都给大家标注出来了，大家前期不用死记硬背，后面开发学习过程中，用的多了， 自然就记住目录下每个文件的作用了。<br><img src="https://pic.imgdb.cn/item/63d68753face21e9ef444f69.png"></p>
<h1 id="四、小程序开发三剑客"><a href="#四、小程序开发三剑客" class="headerlink" title="四、小程序开发三剑客"></a>四、小程序开发三剑客</h1><h2 id="4-1、小程序三剑客-wxml-wxss-js"><a href="#4-1、小程序三剑客-wxml-wxss-js" class="headerlink" title="4-1、小程序三剑客: wxml+wxss+js"></a>4-1、小程序三剑客: wxml+wxss+js</h2><p>1，	wxml主要用来布局组件的（相当于大楼结构）<br>如：楼有几层，每层有多少房间，有什么设备<br>2，	wxss主要决定显示样式（决定大楼的样式）<br>如：颜色，大小，宽高等<br>3，	js主要用来处理逻辑（决定大楼具备哪些功能）<br>如：大楼具有电梯功能，空调制冷，灯光，供水，供电，主要是为了大厦的运行。</p>
<p>下面画个图，来说明三者的关系。<br><img src="https://pic.imgdb.cn/item/63d68766face21e9ef44aca4.png"></p>
<h2 id="4-2、小程序文件和传统web对比"><a href="#4-2、小程序文件和传统web对比" class="headerlink" title="4-2、小程序文件和传统web对比"></a>4-2、小程序文件和传统web对比</h2><table>
<thead>
<tr>
<th>结构</th>
<th>小程序</th>
<th>传统web</th>
</tr>
</thead>
<tbody><tr>
<td>结构布局</td>
<td>Wxml</td>
<td>Html</td>
</tr>
<tr>
<td>样式</td>
<td>Wxss</td>
<td>Css</td>
</tr>
<tr>
<td>逻辑</td>
<td>JavaScript</td>
<td>JavaScript</td>
</tr>
<tr>
<td>配置</td>
<td>Json</td>
<td>无</td>
</tr>
</tbody></table>
<h1 id="五、小程序常见组件的学习"><a href="#五、小程序常见组件的学习" class="headerlink" title="五、小程序常见组件的学习"></a>五、小程序常见组件的学习</h1><h2 id="5-1、认识view组件"><a href="#5-1、认识view组件" class="headerlink" title="5-1、认识view组件"></a>5-1、认识view组件</h2><p>view组件：相当于一个盒子，可以用来装一些别的组件<br><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/component/view.html">https://developers.weixin.qq.com/miniprogram/dev/component/view.html</a></p>
<h2 id="5-2、认识text组件"><a href="#5-2、认识text组件" class="headerlink" title="5-2、认识text组件"></a>5-2、认识text组件</h2><p>text组件：主要用来显示文字的<br><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/component/text.html">https://developers.weixin.qq.com/miniprogram/dev/component/text.html</a></p>
<h2 id="5-3、认识input组件"><a href="#5-3、认识input组件" class="headerlink" title="5-3、认识input组件"></a>5-3、认识input组件</h2><p>input组件主要用来获取用户输入的信息的，一般在用户填写信息，提交数据，登录注册时会用到。<br><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/component/input.html">https://developers.weixin.qq.com/miniprogram/dev/component/input.html</a></p>
<h2 id="5-4、认识button组件"><a href="#5-4、认识button组件" class="headerlink" title="5-4、认识button组件"></a>5-4、认识button组件</h2><p>button 组件：是按钮组件，自带默认的按钮效果，我们后面会经常用到<br><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/component/button.html">https://developers.weixin.qq.com/miniprogram/dev/component/button.html</a></p>
<h1 id="六、函数和事件的学习"><a href="#六、函数和事件的学习" class="headerlink" title="六、函数和事件的学习"></a>六、函数和事件的学习</h1><h2 id="6-2、日志打印的学习"><a href="#6-2、日志打印的学习" class="headerlink" title="6-2、日志打印的学习"></a>6-2、日志打印的学习</h2><p>我们在学习点击事件之前，需要先学习日志(log)的打印，因为我们开发过程中会经常用到日志打印。日志打印的语法如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&quot;我的打印出来的日志内容&quot;)</span><br></pre></td></tr></table></figure>





<h2 id="6-3、函数的学习"><a href="#6-3、函数的学习" class="headerlink" title="6-3、函数的学习"></a>6-3、函数的学习</h2><p>函数的两种使用方式如下图：<br><img src="https://pic.imgdb.cn/item/63d68781face21e9ef452a89.png"></p>
<h2 id="6-4、点击事件的学习"><a href="#6-4、点击事件的学习" class="headerlink" title="6-4、点击事件的学习"></a>6-4、点击事件的学习</h2><p>我们如果想给一个组件定义点击事件，就要用到bindtap，我们给一个组件绑定点击事件的语法如下。<br><img src="https://pic.imgdb.cn/item/63d6878eface21e9ef4561a3.png"><br>我们给一个组件定义点击事件，主要是给组件定义一个 bindtap&#x3D;“事件名”，然后再js页面里定义和事件名一样的函数即可。视频里会作详细讲解</p>
<h2 id="6-5、获取用户输入信息"><a href="#6-5、获取用户输入信息" class="headerlink" title="6-5、获取用户输入信息"></a>6-5、获取用户输入信息</h2><p>我们获取用户输入会用到bindinput事件，其实我们在学习input组件时，官方有给出这个属性的。<a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/component/input.html">https://developers.weixin.qq.com/miniprogram/dev/component/input.html</a><br><img src="https://pic.imgdb.cn/item/63d687a8face21e9ef45c9f8.png"><br>看官方的文档，可以知道bindinput主要是为了获取用户的输入内容。<br>bindinput的定义如下图。<br><img src="https://pic.imgdb.cn/item/63d687bbface21e9ef4629b9.png"><br>在wxml里定义好bindinput事件以后，在js页面再定义一个和事件名一样的函数即可。视频里会作详细讲解。如果你有买老师的课程，或者购买老师的年卡，可以获取对应的学习视频。</p>
<h1 id="七、变量的学习"><a href="#七、变量的学习" class="headerlink" title="七、变量的学习"></a>七、变量的学习</h1><h2 id="7-1，什么是变量"><a href="#7-1，什么是变量" class="headerlink" title="7-1，什么是变量"></a>7-1，什么是变量</h2><p>用大白话讲：变量就是一个装东西的盒子<br>再通俗些讲：变量就是用于存放数据的容器，我们通过变量名获取对应的数据。<br><img src="https://img-blog.csdnimg.cn/20200820121937310.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>如上图所示，我们的盒子(变量)可以装名字，布尔类型的true，还可以用来装数字。<br>变量的本质：就是在程序的内存中申请一块用来存放数据的空间。</p>
<h2 id="7-2、变量的组成"><a href="#7-2、变量的组成" class="headerlink" title="7-2、变量的组成"></a>7-2、变量的组成</h2><p>变量由变量名和存储的值组成，语法如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var x = 7;</span><br><span class="line">var y = 8;</span><br><span class="line">var z = x + y; </span><br><span class="line"></span><br><span class="line">从上例中，您可知道x,y,z是三个不同的变量名：</span><br><span class="line">x 存储值 7</span><br><span class="line">y 存储值 8</span><br><span class="line">z 存储值 15</span><br></pre></td></tr></table></figure>



<h2 id="7-3、变量的命名规范"><a href="#7-3、变量的命名规范" class="headerlink" title="7-3、变量的命名规范"></a>7-3、变量的命名规范</h2><ul>
<li>名称可包含字母、数字、下划线和美元符号</li>
<li>名称必须以字母开头</li>
<li>名称对大小写敏感（y 和 Y 是不同的变量）</li>
<li>不能是关键字，保留字（比如 JavaScript 的关键词）</li>
<li>遵守驼峰命名法，首字母小写，后面的单词的首字母大写。如userName</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200820125958833.png" alt="img"></p>
<h2 id="7-4、全局变量和局部变量"><a href="#7-4、全局变量和局部变量" class="headerlink" title="7-4、全局变量和局部变量"></a>7-4、全局变量和局部变量</h2><p>局部变量：变量在函数内声明，只能在函数内部访问。<br>全局变量：变量在函数外定义，整个代码都可以调用的变量。<br><img src="https://img-blog.csdnimg.cn/20200820131221377.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>如上图所示的局部变量和全局变量的定义。</p>
<h1 id="八、数据类型"><a href="#八、数据类型" class="headerlink" title="八、数据类型"></a>八、数据类型</h1><h2 id="8-1、认识数据类型"><a href="#8-1、认识数据类型" class="headerlink" title="8-1、认识数据类型"></a>8-1、认识数据类型</h2><p>上一节变量的学习，我们知道变量是用来装数据的盒子，可是数据有很多，有各种各样的类型。不同类型的数据占用的计算器内存也不一样。就好比胖子睡大床，瘦子睡小床就行。<br>在计算机中不同的数据占用的存储空间是不同的，为了便于区分，充分利用存储空间，于是就定义了不同的数据类型。<br>简单来说，数据类型就是数据的类别型号，比如“张三”是个人名，18是个数字</p>
<h2 id="8-2，常见的数据类型"><a href="#8-2，常见的数据类型" class="headerlink" title="8-2，常见的数据类型"></a>8-2，常见的数据类型</h2><p>我们的数据类型可以分成下面两大类</p>
<ul>
<li>简单数据类型(Number String Boolean Undefined Null)</li>
<li>复杂数据类型(Object)</li>
</ul>
<h3 id="简单数据类型"><a href="#简单数据类型" class="headerlink" title="简单数据类型"></a>简单数据类型</h3><table>
<thead>
<tr>
<th>简单数据类型</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>Number</td>
<td>数字型，包含整数和小数，如 18，18.8</td>
<td>0</td>
</tr>
<tr>
<td>String</td>
<td>字符串型，如“小石头”。注意js里字符串都要带引号</td>
<td>“”</td>
</tr>
<tr>
<td>Boolean</td>
<td>布尔值类型，就true和false两个值，代表正确和错误</td>
<td>false</td>
</tr>
<tr>
<td>Undefined</td>
<td>Undefined 这个值表示变量不含有值,如var a;声明了变量a，但是没有赋值，就是undefined</td>
<td>undefined</td>
</tr>
<tr>
<td>Null</td>
<td>空值，如var a&#x3D;null,声明了变量a为空值</td>
<td>null</td>
</tr>
</tbody></table>
<h2 id="8-3、数字型Number"><a href="#8-3、数字型Number" class="headerlink" title="8-3、数字型Number"></a>8-3、数字型Number</h2><p>js数字类型的数据，既可以是整数，也可以是小数(浮点数)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var age=21	//整数</span><br><span class="line">var PI=3.1415	//小数</span><br></pre></td></tr></table></figure>



<h2 id="8-4、字符串String"><a href="#8-4、字符串String" class="headerlink" title="8-4、字符串String"></a>8-4、字符串String</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var name=&quot;jelly&quot;	//字符串</span><br><span class="line">var age1=&quot;18&quot;		//字符串</span><br><span class="line">var age2=18		//数字型</span><br></pre></td></tr></table></figure>



<p>上面代码的age1和age2是有区别的，age1的18被双引号包裹着，所以是字符串，age2就是一个数字18，所以是数字型。这也进一步说明了，只要是被单引号或者双引号包裹着的都是字符串类型。</p>
<h3 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h3><p>字符串是由若干字符组成的，这些字符的数量就是字符串的长度，通过字符串的length属性可以获取整个字符串的长度。<br>还是拿羊肉串来类比，比如你一个羊肉串上串了5块羊肉，那么这个羊肉串的长度就是5。<br>使用的语法如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var name=&quot;jelly&quot;</span><br><span class="line">console.log(name.length)	//这里的输出结果是5</span><br></pre></td></tr></table></figure>



<h3 id="字符串的拼接"><a href="#字符串的拼接" class="headerlink" title="字符串的拼接"></a>字符串的拼接</h3><p>多个字符串之间可以使用 + 进行拼接，其拼接方式为 字符串+字符串&#x3D;拼接之后的新字符串。<br>语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var name=&quot;jelly&quot;</span><br><span class="line">var weixin=123455</span><br><span class="line">var test=name+weixin</span><br><span class="line">console.log(test) //输出结果：&quot;jelly123455&quot;</span><br><span class="line">console.log(12+12)//输出结果：24</span><br><span class="line">console.log(&quot;12&quot;+12)//输出结果：1212</span><br></pre></td></tr></table></figure>



<p>上面的12+12&#x3D;24，“12”+12&#x3D;“1212” 这就告诉我们字符串加任何类型的数据，拼接后的结果都是字符串。</p>
<h2 id="8-5、布尔型Boolean"><a href="#8-5、布尔型Boolean" class="headerlink" title="8-5、布尔型Boolean"></a>8-5、布尔型Boolean</h2><p>布尔类型有两个值：true和false，其中true表示真，false表示假。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var flag=true</span><br></pre></td></tr></table></figure>



<h2 id="8-6、Undefined和Null"><a href="#8-6、Undefined和Null" class="headerlink" title="8-6、Undefined和Null"></a>8-6、Undefined和Null</h2><p>一个声明后没有赋值的变量会有一个默认值 undefined<br>一个声明变量，并且赋值null，就代表这个变量是空值(学习object对象时，我们会继续研究null)<br>null 和 undefined 的值相等，但类型不同，下面的8-7会有代码演示</p>
<h2 id="8-7、typeof-操作符"><a href="#8-7、typeof-操作符" class="headerlink" title="8-7、typeof 操作符"></a>8-7、typeof 操作符</h2><p>typeof 操作符用来检测变量的数据类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typeof &quot;John&quot;                // 返回 string </span><br><span class="line">typeof 3.14                  // 返回 number</span><br><span class="line">typeof false                 // 返回 boolean</span><br></pre></td></tr></table></figure>



<p>打印null和undefined的数据类型如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var aaa=undefined</span><br><span class="line">var bbb=null</span><br><span class="line">console.log(aaa==bbb)//输出结果：true</span><br><span class="line">console.log(typeof aaa)//输出结果：undefined</span><br><span class="line">console.log(typeof bbb)//输出结果：object</span><br></pre></td></tr></table></figure>



<p>注意：这里的 &#x3D;&#x3D; 用来判断值是否相等，后面会讲。<br>上面的代码可以看出：null 和 undefined 的值相等，但类型不同</p>
<h2 id="8-8、数据类型的转换"><a href="#8-8、数据类型的转换" class="headerlink" title="8-8、数据类型的转换"></a>8-8、数据类型的转换</h2><p>就是把一种数据类型的变量转换成另外一种数据类型，比如把字符串的 “18”转换为数字类型的18<br>常用的数据类型转换</p>
<ul>
<li>把其他类型转为字符串型</li>
<li>把其他类型转为数字型</li>
</ul>
<h3 id="转换为字符串"><a href="#转换为字符串" class="headerlink" title="转换为字符串"></a>转换为字符串</h3><table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
<th>案例</th>
</tr>
</thead>
<tbody><tr>
<td>toString()</td>
<td>转为字符串</td>
<td>var num&#x3D;1  num.toString()</td>
</tr>
<tr>
<td>String()</td>
<td>转为字符串</td>
<td>var num&#x3D;1  String(num)</td>
</tr>
<tr>
<td>用加号拼接字符串</td>
<td>转为字符串</td>
<td>var num&#x3D;1  “”+num</td>
</tr>
</tbody></table>
<h3 id="转换为数字型（重点）"><a href="#转换为数字型（重点）" class="headerlink" title="转换为数字型（重点）"></a>转换为数字型（重点）</h3><table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
<th>案例</th>
</tr>
</thead>
<tbody><tr>
<td>Number()</td>
<td>将字符串转换为数字</td>
<td>Number(“3.14”)   &#x2F;&#x2F; 返回 3.14</td>
</tr>
<tr>
<td>parseFloat()</td>
<td>解析一个字符串并返回一个浮点数</td>
<td>parseFloat(“3.12”) <a href="http://xn--3-pd0bu36o.12">&#x2F;&#x2F;返回3.12</a></td>
</tr>
<tr>
<td>parseInt()</td>
<td>解析一个字符串并返回一个整数</td>
<td>parseInt(“3.12”) &#x2F;&#x2F;返回3</td>
</tr>
</tbody></table>
<p>转为数字的几个特殊情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(Number(&quot;&quot;))//空字符串转换为 0</span><br><span class="line">console.log(Number(true))//true转换为1</span><br><span class="line">console.log(Number(false))//false转换为0</span><br><span class="line">console.log(Number(&quot;编程小石头&quot;))//其他的字符串会转换为 NaN (不是个数字)</span><br></pre></td></tr></table></figure>



<h1 id="九、综合小案例"><a href="#九、综合小案例" class="headerlink" title="九、综合小案例"></a>九、综合小案例</h1><h2 id="9-1、数据绑定"><a href="#9-1、数据绑定" class="headerlink" title="9-1、数据绑定"></a>9-1、数据绑定</h2><p>在学习这个综合案例之前，我们需要先学习下小程序的动态数据绑定。数据绑定的语法如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--wxml--&gt;</span><br><span class="line">&lt;view&gt; &#123;&#123;message&#125;&#125; &lt;/view&gt;</span><br><span class="line"></span><br><span class="line">// js里如下</span><br><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &#x27;我是动态绑定的数据&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h2 id="9-2、效果图预览"><a href="#9-2、效果图预览" class="headerlink" title="9-2、效果图预览"></a>9-2、效果图预览</h2><p>上一节和大家讲解了小程序的一些常用组件，这节就带大家写出自己的第一个简单计算器。做一个综合性的练习。由于是入门，这里先教大家简单的加法运算。效果图如下<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy82MjczNzEzLTJmMmM3M2UxNzc3NmM4ZmIucG5n?x-oss-process=image/format,png" alt="img"><br>实现起来特别简单，代码也特别少，就下面三个</p>
<ul>
<li>index.wxml：上图的布局视图页</li>
<li>index.js：实现加法逻辑的页面</li>
<li>app.json：一些全局的配置。基本是都是默认的这里不用管<br>下面就带带大家敲出属于自己的计算器小程序代码。</li>
</ul>
<h2 id="9-3、先看index-wxml"><a href="#9-3、先看index-wxml" class="headerlink" title="9-3、先看index.wxml"></a>9-3、先看index.wxml</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--index.wxml  --&gt;</span><br><span class="line">&lt;input placeholder=&quot;请输入数字a&quot; bindinput=&quot;inputa&quot; /&gt;</span><br><span class="line">&lt;text&gt;+&lt;/text&gt;</span><br><span class="line">&lt;input placeholder=&quot;请输入数字b&quot; bindinput=&quot;inputb&quot; /&gt;</span><br><span class="line">&lt;button bindtap=&#x27;sum&#x27;&gt;计算&lt;/button&gt;</span><br><span class="line">&lt;text&gt;结果为：&#123;&#123;result&#125;&#125;&lt;/text&gt;</span><br><span class="line">&lt;input placeholder=&quot;请输入数字a&quot; bindinput=&quot;inputa&quot; /&gt; </span><br><span class="line">&lt;input placeholder=&quot;请输入数字b&quot; bindinput=&quot;inputb&quot; /&gt;</span><br></pre></td></tr></table></figure>



<p>就是我们输入数字a的输入框，这里input就是我们认识的第一个小程序组件。<br>input的官方简介如下：<a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/component/input.html">https://developers.weixin.qq.com/miniprogram/dev/component/input.html</a><br>placeholder：设置默认显示文字（当我们输入文字时，默认的就没有了）<br>bindinput&#x3D;”inputa”：定义一个inputa方法来获取input的输入内容。在index.js中会用到</p>
<ul>
<li><ul>
<li>这里的组件是用来显示文本的这里我们只是为了显示一个 + 号</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button bindtap=&#x27;sum&#x27;&gt;计算&lt;/button&gt;</span><br></pre></td></tr></table></figure>



<p>这里是个按钮就是我们的计算按钮<br>bindtap&#x3D;’sum’：定义个叫sum的方法，用来计算结果在index.js中会用到</p>
<ul>
<li>结果为：  这种写法，是小程序用来绑定数据用的，这里用来显示我们的计算结果用的，</li>
</ul>
<h4 id="上面代码和对应的显示如下："><a href="#上面代码和对应的显示如下：" class="headerlink" title="上面代码和对应的显示如下："></a>上面代码和对应的显示如下：</h4><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy82MjczNzEzLWNiMzY1MzI2MGQzNWQ4MzcuanBn?x-oss-process=image/format,png" alt="img"></p>
<h2 id="9-4、再来看index-js，我们加法的逻辑实现"><a href="#9-4、再来看index-js，我们加法的逻辑实现" class="headerlink" title="9-4、再来看index.js，我们加法的逻辑实现"></a>9-4、再来看index.js，我们加法的逻辑实现</h2><p>可以看到我们在index.wxml里定义的bindinput&#x3D;”inputa”，bindtap&#x3D;’sum’在下面有用到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  /**</span><br><span class="line">     * 页面的初始数据</span><br><span class="line">     * 初始化两个输入值</span><br><span class="line">     */</span><br><span class="line">  data: &#123;</span><br><span class="line">    input1: 0,</span><br><span class="line">    input2: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  //获取用户输入的值a</span><br><span class="line">  inputa: function (e) &#123;</span><br><span class="line">    this.setData(&#123;</span><br><span class="line">      input1: e.detail.value</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  //获取用户输入的值b</span><br><span class="line">  inputb: function (e) &#123;</span><br><span class="line">    this.setData(&#123;</span><br><span class="line">      input2: e.detail.value</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  // 拿到两个输入值以后求和</span><br><span class="line">  sum: function (e) &#123;</span><br><span class="line">    var a = parseInt(this.data.input1);</span><br><span class="line">    var b = parseInt(this.data.input2);</span><br><span class="line">    // 求和</span><br><span class="line">    var sumResult = a + b</span><br><span class="line">    this.setData(&#123;</span><br><span class="line">      // 把结果赋值到sum标签上</span><br><span class="line">      result: sumResult</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h1 id="十、运算符"><a href="#十、运算符" class="headerlink" title="十、运算符"></a>十、运算符</h1><p>运算符也被称为操作符，是用于实现赋值，比较和运算等功能的符号。</p>
<h2 id="10-1、算数运算符"><a href="#10-1、算数运算符" class="headerlink" title="10-1、算数运算符"></a>10-1、算数运算符</h2><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>例子</th>
<th>x 运算结果</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>加法</td>
<td>x&#x3D;5+2</td>
<td>7</td>
</tr>
<tr>
<td>-</td>
<td>减法</td>
<td>x&#x3D;5-2</td>
<td>3</td>
</tr>
<tr>
<td>*</td>
<td>乘法</td>
<td>x&#x3D;5*2</td>
<td>10</td>
</tr>
<tr>
<td>&#x2F;</td>
<td>除法</td>
<td>x&#x3D;5&#x2F;2</td>
<td>2.5</td>
</tr>
<tr>
<td>%</td>
<td>取模（余数）</td>
<td>x&#x3D;5%2</td>
<td>1</td>
</tr>
</tbody></table>
<h2 id="10-2、表达式和返回值"><a href="#10-2、表达式和返回值" class="headerlink" title="10-2、表达式和返回值"></a>10-2、表达式和返回值</h2><p>表达式：是由数字，运算符，变量等以能求得结果的有意义的操作组成的式子。<br>表达式最终都会有一个结果返回给我们，这个返回结果我们称之为返回值</p>
<ul>
<li>如  let x&#x3D;1+1<br>这里的1+1就是由数字和加号组成的表达式，然会返回结果2赋值给x，那么x的值就是2。通俗的讲就是先把右边的表达式计算完毕然后把值返回给左边的x。</li>
</ul>
<h2 id="10-3、比较运算符"><a href="#10-3、比较运算符" class="headerlink" title="10-3、比较运算符"></a>10-3、比较运算符</h2><p>比较运算符是两个数据进行比较时所使用的运算符，比较运算以后会返回一个布尔值的结果，就是返回对或者错(true或false)</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>案例</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;</td>
<td>小于号</td>
<td>1&lt;2</td>
<td>true</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于号</td>
<td>1&gt;2</td>
<td>false</td>
</tr>
<tr>
<td>&gt;&#x3D;</td>
<td>大于等于号(大于或等于)</td>
<td>1&gt;&#x3D;2</td>
<td>false</td>
</tr>
<tr>
<td>&lt;&#x3D;</td>
<td>小于等于号(小于或等于)</td>
<td>1&lt;&#x3D;2</td>
<td>true</td>
</tr>
<tr>
<td>&#x3D;&#x3D;</td>
<td>判等号(判断是否相等)</td>
<td>1&#x3D;&#x3D;1</td>
<td>true</td>
</tr>
<tr>
<td>&#x3D;&#x3D;&#x3D;</td>
<td>绝对等于（值和类型均相等）</td>
<td>1&#x3D;&#x3D;&#x3D;’1’</td>
<td>false</td>
</tr>
<tr>
<td>!&#x3D;</td>
<td>不等于</td>
<td>1!&#x3D;1</td>
<td>false</td>
</tr>
</tbody></table>
<h2 id="10-4、赋值运算符"><a href="#10-4、赋值运算符" class="headerlink" title="10-4、赋值运算符"></a>10-4、赋值运算符</h2><p>赋值运算符向 JavaScript 变量赋值。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>例子</th>
<th>等同于</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;</td>
<td>x &#x3D; y</td>
<td>x &#x3D; y</td>
<td></td>
</tr>
<tr>
<td>+&#x3D;</td>
<td>x +&#x3D; y</td>
<td>x &#x3D; x + y</td>
<td></td>
</tr>
<tr>
<td>-&#x3D;</td>
<td>x -&#x3D; y</td>
<td>x &#x3D; x - y</td>
<td></td>
</tr>
<tr>
<td>*&#x3D;</td>
<td>x *&#x3D; y</td>
<td>x &#x3D; x * y</td>
<td></td>
</tr>
<tr>
<td>&#x2F;&#x3D;</td>
<td>x &#x2F;&#x3D; y</td>
<td>x &#x3D; x &#x2F; y</td>
<td></td>
</tr>
<tr>
<td>%&#x3D;</td>
<td>x %&#x3D; y</td>
<td>x &#x3D; x % y</td>
<td></td>
</tr>
</tbody></table>
<p>&#x3D;的小结</p>
<ul>
<li>&#x3D;：赋值，把右边赋值给左边  如a&#x3D;b</li>
<li>&#x3D;&#x3D;:判断，判断两边的值是否相等 如 a &#x3D;&#x3D;b</li>
<li>&#x3D;&#x3D;&#x3D; :全等，判断两边的值和数据类型是否完全相等 如 a  &#x3D;&#x3D;&#x3D;  b</li>
</ul>
<h2 id="10-5、逻辑运算符"><a href="#10-5、逻辑运算符" class="headerlink" title="10-5、逻辑运算符"></a>10-5、逻辑运算符</h2><p>用于多个条件的判断,其返回值是布尔值。</p>
<ul>
<li>&amp;&amp;	 逻辑与，两个条件都要满足,两侧都是true结果才为true</li>
<li>||	逻辑或,两个条件只需要满足一个即可，有一侧是真结果就真</li>
<li>!	 逻辑非 not，逻辑取反，如true的相反值是false</li>
</ul>
<h2 id="10-6、递增和递减运算符"><a href="#10-6、递增和递减运算符" class="headerlink" title="10-6、递增和递减运算符"></a>10-6、递增和递减运算符</h2><p>递增和递减运算符概述：如果需要反复的给数字变量加或减去1，可以使用递增() 和递减(–)运算符来完成。<br>在js里递增() 和递减(–)既可以放在变量前面，也可以放在变量后面，放在前面时称为前置递增或递减运算符，放在后面时称为后置递增或递减运算符。<br>注意：递增或者递减只能操作变量，不能直接操作数字。</p>
<h3 id="10-6-1、前置递增递减运算符"><a href="#10-6-1、前置递增递减运算符" class="headerlink" title="10-6-1、前置递增递减运算符"></a>10-6-1、前置递增递减运算符</h3><p>注意：前置递增或递减时，是先自加或自减，然后返回值<br>我们之前想要一个变量加1写法如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var num=1</span><br><span class="line">num=num+1 //这里就是给num加1</span><br></pre></td></tr></table></figure>



<p>我们有没有方便的写法呢，上面的num&#x3D;num+1，可以直接写成 ++num，这样是不是更简洁。</p>
<h3 id="10-6-2、后置递增递减运算符"><a href="#10-6-2、后置递增递减运算符" class="headerlink" title="10-6-2、后置递增递减运算符"></a>10-6-2、后置递增递减运算符</h3><p>注意：后置递增或递减时，先返回值，然后自加或自减</p>
<h3 id="10-6-3、前置和后置的区别"><a href="#10-6-3、前置和后置的区别" class="headerlink" title="10-6-3、前置和后置的区别"></a>10-6-3、前置和后置的区别</h3><ul>
<li>前置和后置如果单独使用，效果是一样的</li>
<li>前置是先自加或自减，然后返回值；后置先返回值，然后自加或自减</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var num=10</span><br><span class="line">console.log(++num  +10)//结果是21</span><br><span class="line">console.log(num++  +10)//结果是20</span><br></pre></td></tr></table></figure>



<p>我们通过下面几个小例子来强化理解下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var a=10</span><br><span class="line">++a</span><br><span class="line">console.log(b)//这里b的结果是几</span><br><span class="line"></span><br><span class="line">var c=10</span><br><span class="line">c++</span><br><span class="line">var d=c++ +2</span><br><span class="line">console.log(d)//这里d的结果是几</span><br><span class="line"></span><br><span class="line">var e=10</span><br><span class="line">var f=e++ + ++e</span><br><span class="line">console.log(f)//这里f的结果是几</span><br></pre></td></tr></table></figure>



<h3 id="10-6-4、前置和后置递增递减的小结"><a href="#10-6-4、前置和后置递增递减的小结" class="headerlink" title="10-6-4、前置和后置递增递减的小结"></a>10-6-4、前置和后置递增递减的小结</h3><ul>
<li>前置和后置的主要目的是为了简化代码编写</li>
<li>单独使用递增或递减时，前置和后置效果一样</li>
<li>与其他运算连用时，执行结果会不同<br>后置：先返回原值，后自加（先人后己）<br>前置：先自加，后返回值(先己后人)<br>可以总结为：前置自私，后置无私</li>
<li>开发时，大多使用后置递增&#x2F;减。例如 num++或num- -</li>
</ul>
<h1 id="十一、条件语句和循环语句"><a href="#十一、条件语句和循环语句" class="headerlink" title="十一、条件语句和循环语句"></a>十一、条件语句和循环语句</h1><h2 id="11-1、流程控制"><a href="#11-1、流程控制" class="headerlink" title="11-1、流程控制"></a>11-1、流程控制</h2><p>在学习条件语句河循环语句之前，我们要先知道什么是流程控制，<br><strong>流程控制：</strong>流程控制就是来控制我们的代码按照什么顺序来执行的语句。<br>流程控制主要有三种结构</p>
<ul>
<li>顺序结构</li>
<li>分支结构</li>
<li>循环结构<br><img src="https://img-blog.csdnimg.cn/20201106153524611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>顺序结构是程序中最简单，最基础的流程控制，就是代码按照先后顺序依次执行。我们重点是讲解分支结构和循环结构。</li>
</ul>
<h2 id="11-2、分支结构"><a href="#11-2、分支结构" class="headerlink" title="11-2、分支结构"></a>11-2、分支结构</h2><p><strong>常用的分支结构的语句:</strong></p>
<ul>
<li>if语句</li>
<li>switch语句</li>
</ul>
<p><strong>条件语句:</strong> 用于基于不同条件执行不同的动作,通常在写代码时，您总是需要为不同的决定来执行不同的动作。您可以在代码中使用条件语句来完成该任务。<br><img src="https://img-blog.csdnimg.cn/20201106154332325.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>举个最简单的例子：你满18岁就可以去网吧，不满18岁就不允许进网吧。这里的判断条件就是你的年纪。<br>我们这里常用的就是if条件语句，所以接下来我们会重点讲解下if条件语句。</p>
<h2 id="11-3、if条件语句"><a href="#11-3、if条件语句" class="headerlink" title="11-3、if条件语句"></a>11-3、if条件语句</h2><p>在 JavaScript 中，我们可使用以下条件语句：</p>
<ul>
<li>if 语句 - 只有当指定条件为 true 时，使用该语句来执行代码</li>
<li>if…else 语句 - 当条件为 true 时执行代码，当条件为 false 时执行其他代码</li>
<li>if…else if….else 语句- 使用该语句来选择多个代码块之一来执行</li>
</ul>
<h3 id="11-3-1、if-语句"><a href="#11-3-1、if-语句" class="headerlink" title="11-3-1、if 语句"></a>11-3-1、if 语句</h3><p>使用 if 语句来规定假如条件为 true 时被执行的 JavaScript 代码块。</p>
<ul>
<li>语法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (条件) &#123;</span><br><span class="line">    如果条件为 true 时执行的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>实例</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (age&lt; 18) &#123;</span><br><span class="line">   console.log(&quot;未成年&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如果年龄小于18岁，就输出未成年</p>
<h3 id="11-3-2、if-else-双分支语句"><a href="#11-3-2、if-else-双分支语句" class="headerlink" title="11-3-2、if else 双分支语句"></a>11-3-2、if else 双分支语句</h3><p>使用 else 语句来规定假如条件为 false 时的代码块。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (条件) &#123;</span><br><span class="line">    条件为 true 时执行的代码块</span><br><span class="line">&#125; else &#123; </span><br><span class="line">    条件为 false 时执行的代码块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>实例</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (age &lt; 18) &#123;</span><br><span class="line">     console.log(&quot;未成年&quot;)</span><br><span class="line"> &#125; else &#123;</span><br><span class="line">    console.log(&quot;成年&quot;)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<p>如果年龄小于18岁，就输出未成年，否则就输出成年</p>
<h3 id="11-3-3、if-else-if-多分支语句"><a href="#11-3-3、if-else-if-多分支语句" class="headerlink" title="11-3-3、if else if 多分支语句"></a>11-3-3、if else if 多分支语句</h3><p>使用 else if 来规定当首个条件为 false 时的新条件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">语法</span><br><span class="line">if (条件 1) &#123;</span><br><span class="line">    条件 1 为 true 时执行的代码块</span><br><span class="line">&#125; else if (条件 2) &#123;</span><br><span class="line">    条件 1 为 false 而条件 2 为 true 时执行的代码块</span><br><span class="line"> &#125; else &#123;</span><br><span class="line">    条件 1 和条件 2 同时为 false 时执行的代码块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>实例</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (age &lt; 18) &#123;</span><br><span class="line">     console.log(&quot;未成年&quot;)</span><br><span class="line"> &#125; else if(age&lt;60) &#123;</span><br><span class="line">    console.log(&quot;成年&quot;)</span><br><span class="line"> &#125; else &#123;</span><br><span class="line">    console.log(&quot;老年&quot;)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<p>如果年龄小于18岁，就输出未成年，年龄大于18岁小于60岁就输出成年，年龄大于60岁就输出老年。</p>
<h2 id="11-4-、wxml条件渲染"><a href="#11-4-、wxml条件渲染" class="headerlink" title="11-4 、wxml条件渲染"></a>11-4 、wxml条件渲染</h2><p>在wxml中，使用 wx:if&#x3D;”” 来判断是否需要渲染该代码块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;view wx:if=&quot;&#123;&#123;condition&#125;&#125;&quot;&gt; 我是可以显示的&lt;/view&gt;</span><br></pre></td></tr></table></figure>



<p>也可以用 wx:elif 和 wx:else 来添加一个 else 块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;view wx:if=&quot;&#123;&#123;length &gt; 5&#125;&#125;&quot;&gt; 1 &lt;/view&gt;</span><br><span class="line">&lt;view wx:elif=&quot;&#123;&#123;length &gt; 2&#125;&#125;&quot;&gt; 2 &lt;/view&gt;</span><br><span class="line">&lt;view wx:else&gt; 3 &lt;/view&gt;</span><br></pre></td></tr></table></figure>



<p>可以看出wxml里的条件渲染和我们上面讲的if条件语句类似，只是写法上稍微有些区别。<br>wxml里的条件渲染主要用来做页面展示和隐藏使用的。</p>
<h2 id="11-5、for循环语句"><a href="#11-5、for循环语句" class="headerlink" title="11-5、for循环语句"></a>11-5、for循环语句</h2><p>如果您希望一遍又一遍地运行相同的代码，并且每次的值都不同，那么使用循环是很方便的。<br>比如我们想输出5次</p>
<ul>
<li>一般写法</li>
</ul>
<p>console.log(“jelly”)</p>
<p>console.log(“jelly”)</p>
<p>console.log(“jelly”)</p>
<p>console.log(“jelly”)</p>
<p>console.log(“jelly”)</p>
<ul>
<li>使用for循环</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (var i=0;i&lt;5;i++)&#123; </span><br><span class="line">  console.log(&quot;jelly&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="for-循环的语法："><a href="#for-循环的语法：" class="headerlink" title="for 循环的语法："></a>for 循环的语法：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (初始化变量; 条件表达式; 操作表达式)&#123;</span><br><span class="line">    被执行的代码块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>初始化变量：开始前第一个执行，通常用于初始化计数器变量，只执行一次。</li>
<li>条件表达式：就是用来决定每一次循环是否可以继续执行， 定义运行循环的终止条件</li>
<li>操作表达式：在大括号里的代码块已被执行之后执行，通常用于对我们的计数器变量进行递增或者递减操作。</li>
</ul>
<p>实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (var i=0;i&lt;5;i++)&#123; </span><br><span class="line">  console.log(&quot;jelly&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>上面实例中<br>语句1：var i&#x3D;0 是在开始执行前初始化变量i<br>语句2:i&lt;5 是用来判断i是否小于5，如果小于5就继续执行循环<br>语句3：i++ 是在每次循环执行一遍后对i进行加1的操作</p>
<h2 id="11-6、wxml列表渲染"><a href="#11-6、wxml列表渲染" class="headerlink" title="11-6、wxml列表渲染"></a>11-6、wxml列表渲染</h2><p>在wxml里我们使用wx:for来显示列表数据。<br>在组件上使用 wx:for 控制属性绑定一个数组，即可使用数组中各项的数据重复渲染该组件。<br>默认数组的当前项的下标变量名默认为 index，数组当前项的变量名默认为 item</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;view wx:for=&quot;&#123;&#123;array&#125;&#125;&quot;&gt;</span><br><span class="line">  &#123;&#123;index&#125;&#125;: &#123;&#123;item.name&#125;&#125;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure>



<p>在js里定义的列表数据如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    array: [&#123;</span><br><span class="line">      name: &#x27;jelly&#x27;,</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      name: &#x27;GD&#x27;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h2 id="11-7、continue和break的学习"><a href="#11-7、continue和break的学习" class="headerlink" title="11-7、continue和break的学习"></a>11-7、continue和break的学习</h2><p>continue和break都是用来终止循环的，区别在于</p>
<ul>
<li>continue：是终止循环中的某一次，继续执行后面的循环</li>
<li>beak: 直接终止整个循环执行，整个循环不在执行</li>
</ul>
<h1 id="十二、数组的学习"><a href="#十二、数组的学习" class="headerlink" title="十二、数组的学习"></a>十二、数组的学习</h1><h2 id="12-1、数组的概念"><a href="#12-1、数组的概念" class="headerlink" title="12-1、数组的概念"></a>12-1、数组的概念</h2><p>数组就是一组数据的集合，可以把更多的数据存储在单个变量下。<br>数组里面可以存储各种类型的数据。<br>如：  var names&#x3D;[‘jelly’,16,true]</p>
<h2 id="12-2、创建数组的两种方式"><a href="#12-2、创建数组的两种方式" class="headerlink" title="12-2、创建数组的两种方式"></a>12-2、创建数组的两种方式</h2><ul>
<li>1、使用new创建数组(不常用)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var names=new Array(); </span><br><span class="line">names[0]=&quot;jelly&quot;;       </span><br><span class="line">names[1]=&quot;刘德华&quot;;</span><br><span class="line">names[2]=&quot;周杰伦&quot;;</span><br></pre></td></tr></table></figure>



<ul>
<li>2、利用数组字面量创建数组(常用)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var names=[&#x27;jelly&#x27;,&#x27;刘德华&#x27;,&#x27;周杰伦&#x27;]</span><br></pre></td></tr></table></figure>



<p>明显看到第二种创建数组的方式比第一种更简洁，所以以后我们创建数组就用第二种方式</p>
<h2 id="12-3、获取数组元素"><a href="#12-3、获取数组元素" class="headerlink" title="12-3、获取数组元素"></a>12-3、获取数组元素</h2><p>我们获取数组元素是通过数组下标来获取的，下标也叫做索引，数组的下标是从0开始的。<br>数组可以通过下标来访问，设置，修改对应的元素值。我们可以通过<br>数组名[下标] 的方式来获取数据中的元素。<br>如 names[0]就可以获取names数组里的第一个元素‘jelly’</p>
<h2 id="12-5、求数组中的最大值"><a href="#12-5、求数组中的最大值" class="headerlink" title="12-5、求数组中的最大值"></a>12-5、求数组中的最大值</h2><p>var nums&#x3D;[1,2,3,4] 这个数组我们很明显就可以看出来4是数组里的最大值，但是如果我们数组里的元素有很多，这个时候你就未必能很快的找出来最大值了，所以我们要想求数组里的最大值，要让代码去实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var nums = [1, 2, 3, 4, 5]</span><br><span class="line">var max = nums[0]</span><br><span class="line">for (var i = 1; i &lt; nums.length; i++) &#123;</span><br><span class="line">  if (max &lt; nums[i]) &#123;</span><br><span class="line">    max = nums[i]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(&#x27;最大值&#x27;, max)  //可以得出最大值是5</span><br></pre></td></tr></table></figure>



<h2 id="12-5、给数组添加新元素"><a href="#12-5、给数组添加新元素" class="headerlink" title="12-5、给数组添加新元素"></a>12-5、给数组添加新元素</h2><p>push() 方法可向数组的末尾添加一个或多个元素，所以我们一般给数组追加元素的时候，直接使用push方法就可以了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var nums = [1, 2, 3, 4, 5]</span><br><span class="line">nums.push(6)</span><br><span class="line">nums.push(7, 8)</span><br><span class="line">console.log(nums) //追加新元素后的数组  [1, 2, 3, 4, 5, 6, 7, 8]</span><br></pre></td></tr></table></figure>



<h2 id="12-6、删除数组中的指定元素"><a href="#12-6、删除数组中的指定元素" class="headerlink" title="12-6、删除数组中的指定元素"></a>12-6、删除数组中的指定元素</h2><p>如我们想把数组中的指定元素删除掉，可以用一个新的数组来接受符合要求的元素，不符合要求的元素不接收，这样就可以实现删除数组元素的效果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 把元素5删除</span><br><span class="line">   var nums = [1, 2, 3, 4, 5]</span><br><span class="line">   //1,定义一个新数组</span><br><span class="line">   var newNums = []</span><br><span class="line">   //2，遍历旧数组</span><br><span class="line">   for (var i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">     //3,把符合要求的元素添加到新的数组里</span><br><span class="line">     if (nums[i] !== 5) &#123;</span><br><span class="line">       newNums.push(nums[i])</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   console.log(newNums) //删除成功 [1, 2, 3, 4]</span><br></pre></td></tr></table></figure>



<h1 id="十三、对象的学习"><a href="#十三、对象的学习" class="headerlink" title="十三、对象的学习"></a>十三、对象的学习</h1><h2 id="13-1、什么是对象"><a href="#13-1、什么是对象" class="headerlink" title="13-1、什么是对象"></a>13-1、什么是对象</h2><p>对象只是一种特殊的数据。对象是一组无序的相关属性和方法组成。这里重点要记住属性和方法这两个新概念</p>
<ul>
<li>属性：事物的特征，对象里的属性就是用来表现该对象具备哪些特征</li>
<li>方法：事物的行为，对象里方法就是用来表示该对象具备哪些行为。</li>
</ul>
<p>例如：<br>哥具备姓名，年龄，身高，体重等属性<br>哥具备写代码，唱歌，骑车，跑步，吃饭等行为。</p>
<ul>
<li>手机具备下面的属性和方法<br><img src="https://img-blog.csdnimg.cn/20201208165824376.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></li>
</ul>
<h2 id="13-2、为什么需要对象"><a href="#13-2、为什么需要对象" class="headerlink" title="13-2、为什么需要对象"></a>13-2、为什么需要对象</h2><p>保存一个数据时，可以用变量，保存多个数据时可以用数组。但是我如果想保存一个完整的立体的信息时呢。</p>
<ul>
<li>比如保存jelly的完整信息。<br>如果我们用数组来表示就是<br>var shitouge&#x3D;[‘jelly’,’男’,’128’,’188’]<br>这样我虽然把jelly的完整信息保存到了数组里，也可以大致猜出来哪些数据代表什么意思，但是后面的128和188是什么意思呢？？？</li>
</ul>
<p>但是我们如果用对象来保存这些信息呢</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">姓名:&#x27;jelly&#x27;,</span><br><span class="line">性别:&#x27;男&#x27;</span><br><span class="line">体重:128</span><br><span class="line">身高:188</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>上面的{}里包裹的就是我们对象的一些属性。只不过我们的属性名不提倡用汉字，应该用英文或者拼音，我这里方便大家理解才这样写的。</p>
<h2 id="13-3、创建对象的三种方式"><a href="#13-3、创建对象的三种方式" class="headerlink" title="13-3、创建对象的三种方式"></a>13-3、创建对象的三种方式</h2><ul>
<li>利用字面量创建对象</li>
<li>利用new Object创建对象</li>
<li>利用构造函数创建对象</li>
</ul>
<h3 id="13-3-1、利用字面量创建对象"><a href="#13-3-1、利用字面量创建对象" class="headerlink" title="13-3-1、利用字面量创建对象"></a>13-3-1、利用字面量创建对象</h3><p>语法如下<br>var 对象名&#x3D;{<br>属性名：属性值，<br>属性名：属性值，<br>方法名：function(){}<br>}</p>
<p>示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var Person = &#123;</span><br><span class="line"> name:&#x27;jelly&#x27;,</span><br><span class="line"> age:18,</span><br><span class="line"> code:function()&#123;console.log(&#x27;jelly好好看&#x27;)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="13-3-2、利用new-Object创建对象"><a href="#13-3-2、利用new-Object创建对象" class="headerlink" title="13-3-2、利用new Object创建对象"></a>13-3-2、利用new Object创建对象</h3><p>语法：<br>var obj &#x3D; new Object();<br>obj.name&#x3D;’jelly’<br>obj.age&#x3D;18<br>我们这里就是先用 new Object()创建一个空对象，然后通过.属性名给这个空对象添加属性和方法</p>
<h3 id="13-3-3、利用构造函数创建对象"><a href="#13-3-3、利用构造函数创建对象" class="headerlink" title="13-3-3、利用构造函数创建对象"></a>13-3-3、利用构造函数创建对象</h3><p>构造函数是一种特殊的函数，主要用来初始化对象，它总是和new运算符一起使用，我们可以把对象里的一些公共属性和方法抽取出来，然后封装到这个函数里，方便批量创建对象。</p>
<p>使用构造函数创建对象时要注意下面几点</p>
<ul>
<li>1，构造函数名字的首字母习惯大写</li>
<li>2，构造函数里不需要return就可以返回结果</li>
<li>3，调用构造函数创建对象时，必须用new</li>
<li>4，我们的属性和方法前面必须添加this</li>
</ul>
<p>完整实例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age) &#123;//创建构造函数Person</span><br><span class="line">     this.name = name;</span><br><span class="line">     this.age = age;</span><br><span class="line">     this.action = function (jineng) &#123;</span><br><span class="line">       console.log(name + &quot;具备&quot; + jineng + &#x27;的技能&#x27;)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   //创建对象1</span><br><span class="line">   var obj1 = new Person(&#x27;jelly&#x27;, 18)</span><br><span class="line">   console.log(obj1.name)//jelly</span><br><span class="line">   obj1.action(&#x27;写代码&#x27;)//jelly具备写代码的技能</span><br><span class="line">    //创建对象2</span><br><span class="line">   var obj2 = new Person(&#x27;周杰伦&#x27;, 41)</span><br><span class="line">   console.log(obj2.name)//周杰伦</span><br><span class="line">   obj2.action(&#x27;唱歌&#x27;)//周杰伦具备唱歌的技能</span><br></pre></td></tr></table></figure>



<p>构造函数和对象<br><img src="https://img-blog.csdnimg.cn/20201208174939302.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>我们这里的构造函数就好比汽车的设计图纸，汽车具备哪些属性，拥有哪些方法，已经提前在图纸上设计好了，我们只需要根据图纸new出来一个对象，比如可以new出来一个宝马车，也可以new出来一辆兰博基尼。</p>
<h3 id="13-3-4、new关键字执行过程"><a href="#13-3-4、new关键字执行过程" class="headerlink" title="13-3-4、new关键字执行过程"></a>13-3-4、new关键字执行过程</h3><p>如上面我们通过构造函数new一个对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age) &#123;//创建构造函数Person</span><br><span class="line">     this.name = name;</span><br><span class="line">     this.age = age;</span><br><span class="line">     this.action = function (jineng) &#123;</span><br><span class="line">       console.log(name + &quot;具备&quot; + jineng + &#x27;的技能&#x27;)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   //创建对象1</span><br><span class="line">   var obj1 = new Person(&#x27;jelly&#x27;, 18)</span><br></pre></td></tr></table></figure>



<p>这里在new一个对象出来时会执行下面四件事</p>
<ul>
<li>1，在电脑内存中创建一个空对象</li>
<li>2，让this指向这个新的对象</li>
<li>3，执行构造函数里的代码，给这个新对象添加属性和方法</li>
<li>4，返回这个新对象如上面的obj1就是我们创建的新对象</li>
</ul>
<h3 id="13-3-5、变量，属性，函数，方法总结"><a href="#13-3-5、变量，属性，函数，方法总结" class="headerlink" title="13-3-5、变量，属性，函数，方法总结"></a>13-3-5、变量，属性，函数，方法总结</h3><p>属性和变量:</p>
<ul>
<li>相同点：<br>都是用来存储数据的。</li>
<li>不同点：<br>变量单独声明并赋值，使用的时候直接使用变量名就可以；<br>属性在对象里面的，不需要声明，使用的时候要用：对象.属性名。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var dog = &#123;</span><br><span class="line">    //属性</span><br><span class="line">    name:&#x27;可可&#x27;，</span><br><span class="line">    age：&#x27;12&#x27;</span><br><span class="line">&#125; </span><br><span class="line">//变量</span><br><span class="line">var num = 12;</span><br><span class="line"></span><br><span class="line">//调用变量：(直接使用变量名进行调用)</span><br><span class="line">console.log(num); </span><br><span class="line">//调用属性：(对象名.属性名)</span><br><span class="line">console.log(dog.name);</span><br></pre></td></tr></table></figure>



<p>函数和方法：</p>
<ul>
<li>相同点：<br>都是实现某种功能。</li>
<li>不同点：<br>函数是单独声明并且调用的，调用方法：函数名()<br>方法存在于对象里面。调用方法：对象名.方法()</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var dog = &#123;</span><br><span class="line">    name:&#x27;可可&#x27;，</span><br><span class="line">    age：&#x27;12&#x27;，</span><br><span class="line">    //方法</span><br><span class="line">    skill：function()&#123;</span><br><span class="line">        console.log(&#x27;汪汪汪&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//函数</span><br><span class="line">function skillDemo()&#123;</span><br><span class="line">    console.log(&quot;睡觉&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//调用函数：(直接使用:函数名(),进行调用)</span><br><span class="line">skillDemo();</span><br><span class="line">//调用方法：(--对象名.方法名()--)</span><br><span class="line">console.log(dog.skill());</span><br></pre></td></tr></table></figure>



<h2 id="13-4、对象的使用"><a href="#13-4、对象的使用" class="headerlink" title="13-4、对象的使用"></a>13-4、对象的使用</h2><h3 id="13-4-1、访问对象的属性"><a href="#13-4-1、访问对象的属性" class="headerlink" title="13-4-1、访问对象的属性"></a>13-4-1、访问对象的属性</h3><p>对象属性的调用语法有两种</p>
<ul>
<li>对象名.属性名</li>
<li>对象名[‘属性名’]</li>
</ul>
<p>如我们对象如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line"> name:&#x27;jelly&#x27;,</span><br><span class="line"> age:18,</span><br><span class="line"> code:function()&#123;console.log(&#x27;jelly好好看&#x27;)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>调用name属性就是  obj.name<br>这里obj就是我们的对象，name就是我们的对象的属性，obj.name里的.就相当于 的 翻译过来就是obj的name<br>另外一种调用属性的方式就是 obj[‘name’]</p>
<h3 id="13-4-2、访问对象的方法"><a href="#13-4-2、访问对象的方法" class="headerlink" title="13-4-2、访问对象的方法"></a>13-4-2、访问对象的方法</h3><p>对象中方法的调用就一种方式：对象名.方法名() 这里的这对小括号是必不可少的。<br>如我们对象如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line"> name:&#x27;编程小石头&#x27;,</span><br><span class="line"> age:18,</span><br><span class="line"> code:function()&#123;console.log(&#x27;jelly好好看&#x27;)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>obj.code() 就是直接调用obj里的code方法</p>
<h1 id="十四、内置对象的学习"><a href="#十四、内置对象的学习" class="headerlink" title="十四、内置对象的学习"></a>十四、内置对象的学习</h1><h2 id="14-1、什么是内置对象"><a href="#14-1、什么是内置对象" class="headerlink" title="14-1、什么是内置对象"></a>14-1、什么是内置对象</h2><p>内置对象就是指Javascript自带的一些对象，供开发者使用，这些对象提供了一些常用的的功能。开发者可以很方便的使用这些内置对象，而不用关心这些内置对象的实现原理。<br>就好比我们使用手机内置的发短信，打电话功能，我们用的时候可以很方便的快速使用，而不用关心打电话的实现原理。这就是我们使用内置对象的原因，主要就是为了快速方便的使用内置对象的</p>
<p>常见的内置对象有Math、Array、Date等</p>
<h2 id="14-2、查阅文档的学习"><a href="#14-2、查阅文档的学习" class="headerlink" title="14-2、查阅文档的学习"></a>14-2、查阅文档的学习</h2><p>因为内置对象的方法太多了，我们不可能把所有的方法都记下来，所以我门就需要时不时的查阅文档，就好比我们查字典一样。<br>常用的学习文档有下面几个</p>
<ul>
<li>MDN<br>官方地址：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript</a></li>
<li>W3cschool<br><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/js/index.asp">https://www.w3school.com.cn/js/index.asp</a></li>
<li>菜鸟教程<br><a target="_blank" rel="noopener" href="https://www.runoob.com/js/js-tutorial.html">https://www.runoob.com/js/js-tutorial.html</a></li>
</ul>
<h2 id="14-3、Math对象的学习"><a href="#14-3、Math对象的学习" class="headerlink" title="14-3、Math对象的学习"></a>14-3、Math对象的学习</h2><p>与其他内置对象不同的是，Math 不是一个构造器对象。Math 的所有属性与方法都是静态的。引用圆周率的写法是 Math.PI，调用正余弦函数的写法是 Math.sin(x)，x 是要传入的参数。也就是说我们的Math可以直接通过Math. 来调用他的属性和方法</p>
<p>由于Math对象的方法比较多，我这里只把开发过程中常用的一些方法做下讲解</p>
<h3 id="14-3-1、Math常用的属性"><a href="#14-3-1、Math常用的属性" class="headerlink" title="14-3-1、Math常用的属性"></a>14-3-1、Math常用的属性</h3><ul>
<li>Math.PI<br>圆周率，一个圆的周长和直径之比，约等于 3.14159</li>
</ul>
<h3 id="14-3-2、Math常用的方法"><a href="#14-3-2、Math常用的方法" class="headerlink" title="14-3-2、Math常用的方法"></a>14-3-2、Math常用的方法</h3><ul>
<li>Math.abs(x)  返回一个数的绝对值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Math.abs(&#x27;-1&#x27;);     // 1</span><br><span class="line">Math.abs(-2);       // 2</span><br><span class="line">Math.abs(null);     // 0</span><br><span class="line">Math.abs(&quot;string&quot;); // NaN</span><br><span class="line">Math.abs();         // NaN</span><br></pre></td></tr></table></figure>



<ul>
<li>Math.max() 返回多个数值的最大值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(Math.max(1, 2, 3)) //3</span><br></pre></td></tr></table></figure>



<ul>
<li>Math.min() 返回多个数值的最小值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(Math.min(1, 2, 3)) //1</span><br></pre></td></tr></table></figure>



<h3 id="14-3-3、Math中取整数的三个方法"><a href="#14-3-3、Math中取整数的三个方法" class="headerlink" title="14-3-3、Math中取整数的三个方法"></a>14-3-3、Math中取整数的三个方法</h3><ul>
<li>Math.ceil(x) 向上取整，往大了取</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(Math.ceil(1.2))//2</span><br><span class="line">   console.log(Math.ceil(1.5))//2</span><br><span class="line">   console.log(Math.ceil(1.7))//2</span><br><span class="line">   console.log(Math.ceil(1.9))//2</span><br></pre></td></tr></table></figure>



<ul>
<li>Math.floor(x) 向下取整，往小了取</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(Math.floor(1.2))//1</span><br><span class="line">console.log(Math.floor(1.5))//1</span><br><span class="line">console.log(Math.floor(1.7))//1</span><br><span class="line">console.log(Math.floor(1.9))//1</span><br></pre></td></tr></table></figure>



<ul>
<li>Math.round(x) 四舍五入取整</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(Math.round(1.2))//1</span><br><span class="line">console.log(Math.round(1.5))//2</span><br><span class="line">console.log(Math.round(1.7))//2</span><br><span class="line">console.log(Math.round(1.9))//2</span><br></pre></td></tr></table></figure>



<h3 id="14-3-4、随机数的学习"><a href="#14-3-4、随机数的学习" class="headerlink" title="14-3-4、随机数的学习"></a>14-3-4、随机数的学习</h3><p>Math.random() 得到一个大于等于0，小于1之间的随机数<br>使用。</p>
<p><strong>使用场景</strong>：一般我们做抽奖时会用到随机数</p>
<ul>
<li>获取两数之间的随机数（大于等于min小于max）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//这个随机数可能是整数，也可能是小数</span><br><span class="line">Math.random() * (max - min) + min</span><br></pre></td></tr></table></figure>



<ul>
<li>得到两数之间的随机整数（大于等于min，小于max）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 这个随机数是min和max之间的随机整数</span><br><span class="line">function getRandomInt(min, max) &#123;</span><br><span class="line">  min = Math.ceil(min);</span><br><span class="line">  max = Math.floor(max);</span><br><span class="line">  //不含最大值，含最小值</span><br><span class="line">  return Math.floor(Math.random() * (max - min)) + min; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>得到两数之间的随机整数，包括两个数在内（大于等于min，小于等于max）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 这个随机数是min和max之间的随机整数</span><br><span class="line">function getRandomIntInclusive(min, max) &#123;</span><br><span class="line">  min = Math.ceil(min);</span><br><span class="line">  max = Math.floor(max);</span><br><span class="line">  //含最大值，含最小值 </span><br><span class="line">  return Math.floor(Math.random() * (max - min + 1)) + min; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="14-4、Date日期对象的学习"><a href="#14-4、Date日期对象的学习" class="headerlink" title="14-4、Date日期对象的学习"></a>14-4、Date日期对象的学习</h2><p>我们的Date对象是一个构造函数对象，必须使用new 对象，来创建我们要使用的对象以后才可以使用。</p>
<p>创建一个新Date对象的唯一方法是通过new 操作符，<br>例如：let now &#x3D; new Date()</p>
<p><strong>使用场景</strong> 比如我们的秒杀倒计时，显示的日期都需要借助Date日期对象</p>
<h3 id="14-4-1、创建Date对象"><a href="#14-4-1、创建Date对象" class="headerlink" title="14-4-1、创建Date对象"></a>14-4-1、创建Date对象</h3><p>有 4 种方法创建新的日期对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new Date()</span><br><span class="line">new Date(year, month, day, hours, minutes, seconds, milliseconds)</span><br><span class="line">new Date(dateString)</span><br><span class="line">new Date(milliseconds)</span><br></pre></td></tr></table></figure>



<ul>
<li>new Date()创建Date对象</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var d = new Date()</span><br><span class="line">console.log(d)//Mon Dec 21 2020 20:02:54 GMT+0800 (中国标准时间)</span><br></pre></td></tr></table></figure>



<p>这样直接创建的返回的是当前的时间如上面的注释所示，我当前是2020年12月21日20时02分54，你打印的应该是你当前自己的时间。</p>
<ul>
<li>new Date(year, month, …)<br>new Date(year, month, …) 用指定日期和时间创建新的日期对象。<br>7个数字分别指定年、月、日、小时、分钟、秒和毫秒（按此顺序）：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var d = new Date(2018, 11, 24, 10, 33, 30, 0);</span><br><span class="line">console.log(d) //Mon Dec 24 2018 10:33:30 GMT+0800 (中国标准时间)</span><br></pre></td></tr></table></figure>



<p>这里有一点需要注意：JavaScript 从 0 到 11 计算月份。一月是 0。十二月是11。<br>4个数字指定年、月、日和小时：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var d = new Date(2018, 11, 24, 10);</span><br></pre></td></tr></table></figure>



<p>3 个数字指定年、月和日：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var d = new Date(2018, 11, 24);</span><br></pre></td></tr></table></figure>



<ul>
<li>new Date(dateString)<br>new Date(dateString) 从日期字符串创建一个新的日期对象<br>我们可以通过 年-月-日 或者年&#x2F;月&#x2F;日 获取Date对象</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//如我们用两种方式来创建2020年12月21日</span><br><span class="line">    var d1 = new Date(2020,11,21);//月份是从0开始的 11代表12月</span><br><span class="line">    console.log(d1) //Mon Dec 21 2020 00:00:00 GMT+0800 (中国标准时间)</span><br><span class="line">    var d2 = new Date(&#x27;2020-12-21&#x27;);</span><br><span class="line">    console.log(d2) //Mon Dec 21 2020 08:00:00 GMT+0800 (中国标准时间)</span><br><span class="line">     var d3 = new Date(&#x27;2020/12/21&#x27;);</span><br><span class="line">    console.log(d3) //Mon Dec 21 2020 08:00:00 GMT+0800 (中国标准时间)</span><br></pre></td></tr></table></figure>



<ul>
<li>new Date(milliseconds)<br>new Date(milliseconds) 创建一个零时加毫秒的新日期对象<br>JavaScript 将日期存储为自 1970 年 1 月 1 日 00:00:00 UTC（协调世界时）以来的毫秒数。<br>零时间是 1970 年 1 月 1 日 00:00:00 UTC。<br>现在的时间是：1970 年 1 月 1 日之后的 1608553621233毫秒<br>如下</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var d1 = new Date(0);</span><br><span class="line">console.log(d1) //Thu Jan 01 1970 08:00:00 GMT+0800 (中国标准时间)</span><br></pre></td></tr></table></figure>



<p>r如果我们想获取当前时间距离1970 年 1 月 1 日之间的毫秒值可以</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var d1 = new Date();</span><br><span class="line">console.log(d1.getTime()) //1608553621233</span><br><span class="line">var d2 = new Date();</span><br><span class="line">console.log(d2) //Mon Dec 21 2020 20:27:01 GMT+0800 (中国标准时间)</span><br></pre></td></tr></table></figure>



<p>可以看出当前时间距离1970 年 1 月 1 日之间的毫秒值是1608553621233<br>那么我们直接new Date(1608553621233)获取的日期如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var d1 = new Date(1608553621233);</span><br><span class="line">console.log(d1) //Mon Dec 21 2020 20:27:01 GMT+0800 (中国标准时间)</span><br></pre></td></tr></table></figure>



<p>所以当前的日期和通过new Date(当前日期距离1970年1月1日的毫秒值)都可以获取当前时间。两者可以相互转换。</p>
<h3 id="14-4-2-日期获取方法"><a href="#14-4-2-日期获取方法" class="headerlink" title="14-4-2,日期获取方法"></a>14-4-2,日期获取方法</h3><p>获取方法用于获取日期的某个部分（来自日期对象的信息）。下面是最常用的方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>getDate()</td>
<td>以数值返回天（1-31）</td>
</tr>
<tr>
<td>getDay()</td>
<td>以数值获取周名（0-6）</td>
</tr>
<tr>
<td>getFullYear()</td>
<td>获取四位的年（yyyy）</td>
</tr>
<tr>
<td>getHours()</td>
<td>获取小时（0-23）</td>
</tr>
<tr>
<td>getMilliseconds()</td>
<td>获取毫秒（0-999）</td>
</tr>
<tr>
<td>getMinutes()</td>
<td>获取分（0-59）</td>
</tr>
<tr>
<td>getMonth()</td>
<td>获取月（0-11）</td>
</tr>
<tr>
<td>getSeconds()</td>
<td>获取秒（0-59）</td>
</tr>
<tr>
<td>getTime()</td>
<td>获取时间（从 1970 年 1 月 1 日至今）</td>
</tr>
</tbody></table>
<h3 id="14-4-3、日期设置方法"><a href="#14-4-3、日期设置方法" class="headerlink" title="14-4-3、日期设置方法"></a>14-4-3、日期设置方法</h3><p>设置方法用于设置日期的某个部分</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>setDate()</td>
<td>以数值（1-31）设置日</td>
</tr>
<tr>
<td>setFullYear()</td>
<td>设置年（可选月和日）</td>
</tr>
<tr>
<td>setHours()</td>
<td>设置小时（0-23）</td>
</tr>
<tr>
<td>setMilliseconds()</td>
<td>设置毫秒（0-999）</td>
</tr>
<tr>
<td>setMinutes()</td>
<td>设置分（0-59）</td>
</tr>
<tr>
<td>setMonth()</td>
<td>设置月（0-11）</td>
</tr>
<tr>
<td>setSeconds()</td>
<td>设置秒（0-59）</td>
</tr>
<tr>
<td>setTime()</td>
<td>设置时间（从 1970 年 1 月 1 日至今的毫秒数）</td>
</tr>
</tbody></table>
<h3 id="14-4-4、倒计时（综合案例）"><a href="#14-4-4、倒计时（综合案例）" class="headerlink" title="14-4-4、倒计时（综合案例）"></a>14-4-4、倒计时（综合案例）</h3><p>我们这里带大家实现一个倒计时的案例，比如我们知道一个活动结束的时间，然后去计算活动还有多久结束。我会在视频里带着大家写一个综合的案例。大家跟着视频课来学习这个综合案例即可。</p>
<h2 id="14-5、Array数组对象的学习"><a href="#14-5、Array数组对象的学习" class="headerlink" title="14-5、Array数组对象的学习"></a>14-5、Array数组对象的学习</h2><p>数组对象的作用是：使用单独的变量名来存储一系列的值。<br>如我之前学习数组时，数组的一种创建方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var mycars = new Array();</span><br><span class="line">mycars[0] = &quot;Saab&quot;;</span><br><span class="line">mycars[1] = &quot;Volvo&quot;;</span><br><span class="line">mycars[2] = &quot;BMW&quot;;</span><br></pre></td></tr></table></figure>



<h3 id="14-5-1、判断是不是数组"><a href="#14-5-1、判断是不是数组" class="headerlink" title="14-5-1、判断是不是数组"></a>14-5-1、判断是不是数组</h3><p>判断一个对象是不是数组有两种方式</p>
<ul>
<li>1，通过instanceof  Array</li>
<li>2，通过Array.isArray(）方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = new Array()</span><br><span class="line">console.log(arr instanceof Array) //true</span><br><span class="line">console.log(Array.isArray(arr))//true</span><br></pre></td></tr></table></figure>



<h3 id="14-5-2、添加和删除数组元素"><a href="#14-5-2、添加和删除数组元素" class="headerlink" title="14-5-2、添加和删除数组元素"></a>14-5-2、添加和删除数组元素</h3><p>其实我们在讲解数组的那一节有教大家如何添加和删除数组，今天再来带大家系统的来学习下数组的添加和删除</p>
<ul>
<li>push方法添加<br>在数组的末尾添加一个或者多个元素</li>
<li>unshift方法添加<br>在数组的开头添加一个或者多个元素</li>
<li>pop方法删除<br>删除数组尾部的元素，一次只能删除一个</li>
<li>shift方法删除<br>删除数组最前面（头部）的元素</li>
</ul>
<h3 id="14-5-3、reverse方法翻转数组"><a href="#14-5-3、reverse方法翻转数组" class="headerlink" title="14-5-3、reverse方法翻转数组"></a>14-5-3、reverse方法翻转数组</h3><p>reverse() 方法将数组中元素的位置颠倒，并返回该数组。数组的第一个元素会变成最后一个，数组的最后一个元素变成第一个。该方法会改变原数组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3, 4, 5]</span><br><span class="line">console.log(arr.reverse())//[5, 4, 3, 2, 1]</span><br></pre></td></tr></table></figure>



<h3 id="14-5-4、sort方法对数组进行排序"><a href="#14-5-4、sort方法对数组进行排序" class="headerlink" title="14-5-4、sort方法对数组进行排序"></a>14-5-4、sort方法对数组进行排序</h3><p>用sort方法进行排序，默认是升序排列的，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 3, 2, 5, 4]</span><br><span class="line">console.log(arr.sort())//[1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure>



<p>但是直接用sort方法会有问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = [11, 3, 22, 55, 44]</span><br><span class="line">console.log(arr.sort())//[11, 22, 3, 44, 55]</span><br></pre></td></tr></table></figure>



<p>为什么会出现3在11和22后面的问题呢，因为我们sort默认排序顺序是在将元素转换为字符串，然后对字符串进行比较，再排序的，所以我们要想用sort来排序，就要用到另外一个写法了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var arr = [11, 3, 22, 55, 44]</span><br><span class="line">//按照升序排序</span><br><span class="line">arr.sort(function (a, b) &#123;</span><br><span class="line">  return a - b</span><br><span class="line">&#125;)</span><br><span class="line">//按照降序排序</span><br><span class="line">arr.sort(function (a, b) &#123;</span><br><span class="line">  return b - a</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>上面的 写法是固定的， a-b时是升序，b-a时是降序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function (a, b) &#123;</span><br><span class="line">      return a - b </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="14-5-5、数组的索引方法"><a href="#14-5-5、数组的索引方法" class="headerlink" title="14-5-5、数组的索引方法"></a>14-5-5、数组的索引方法</h3><ul>
<li>indexOf()方法<br>返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。</li>
<li>lastIndexOf() 方法<br>返回指定元素在数组中的最后一个的索引，如果不存在则返回 -1</li>
</ul>
<h3 id="14-5-6、把数组转换为字符串"><a href="#14-5-6、把数组转换为字符串" class="headerlink" title="14-5-6、把数组转换为字符串"></a>14-5-6、把数组转换为字符串</h3><p>我们把数组转换为字符串有下面两种方法</p>
<ul>
<li>toString()<br>将数组通过逗号连接成一个字符串。</li>
<li>join(分隔符)<br>将数组通过分隔符连接成一个字符串。join里分隔符如果不写的话，默认用逗号来连接数组元素组成一个字符串</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 3, 2, 5, 4]</span><br><span class="line">console.log(arr.toString())//1,3,2,5,4</span><br><span class="line">console.log(arr.join(&#x27;-&#x27;))//1-3-2-5-4</span><br></pre></td></tr></table></figure>



<p>这里希望大家重点掌握，因为我们实际开发中，会把数组转换为字符串传给后台开发人员。</p>
<h3 id="14-5-7、数组的其他常用方法"><a href="#14-5-7、数组的其他常用方法" class="headerlink" title="14-5-7、数组的其他常用方法"></a>14-5-7、数组的其他常用方法</h3><ul>
<li>concat() 方法<br>用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组</li>
<li>slice() 方法<br>截取数组的一部分返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括end）。原始数组不会被改变</li>
<li>splice() 方法<br>通过删除或替换现有元素或者原地添加新的元素来修改或者删除数组<br>splice(从第几个开始，删除几个)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3, 4, 5]</span><br><span class="line">arr.splice(0, 2)// 从索引为0的地方开始，删除2个元素。</span><br><span class="line">console.log(arr) //[3, 4, 5]</span><br></pre></td></tr></table></figure>



<ul>
<li>splice(从第几个开始，替换几个，要替换的值)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]</span><br><span class="line">arr.splice(0, 2,&#x27;A&#x27;,&#x27;B&#x27;)// 从索引为0的地方开始，替换2个元素，替换为 A和B</span><br><span class="line">console.log(arr) //[&quot;A&quot;, &quot;B&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]</span><br></pre></td></tr></table></figure>



<h1 id="十五、wxss和css样式美化"><a href="#十五、wxss和css样式美化" class="headerlink" title="十五、wxss和css样式美化"></a>十五、wxss和css样式美化</h1><p>上面基本上都是JavaScript基础，js在小程序里主要是用来处理逻辑的，样式相关的知识，用来美化我们的小程序。其实我们小程序三剑客里的wxss和我们的css是一样的。</p>
<ul>
<li>菜鸟教程：<a target="_blank" rel="noopener" href="https://www.runoob.com/css/css-tutorial.html">https://www.runoob.com/css/css-tutorial.html</a></li>
<li>w3cshool教程：<a target="_blank" rel="noopener" href="https://www.w3school.com.cn/css/index.asp">https://www.w3school.com.cn/css/index.asp</a></li>
</ul>
<h2 id="15-1、css基础语法"><a href="#15-1、css基础语法" class="headerlink" title="15-1、css基础语法"></a>15-1、css基础语法</h2><p>CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明:<br><img src="https://img-blog.csdnimg.cn/20201224103736458.png" alt="img"><br>在我们小程序的代码里就体现如下</p>
<ul>
<li>1，在wxml里定义一个class选择器<br><img src="https://img-blog.csdnimg.cn/20201224104038440.png" alt="img"></li>
<li>2，在wxss实现css样式<br><img src="https://img-blog.csdnimg.cn/20201224104119913.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></li>
</ul>
<h2 id="15-2、CSS-注释"><a href="#15-2、CSS-注释" class="headerlink" title="15-2、CSS 注释"></a>15-2、CSS 注释</h2><p>注释是用来解释你的代码，并且可以随意编辑它，浏览器会忽略它。<br>CSS注释以 &#x2F; <em>开始, 以</em> &#x2F; 结束, 实例如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*这是个注释*/</span><br><span class="line">.title&#123;</span><br><span class="line">    text-align:center;</span><br><span class="line">    /*这是另一个注释*/</span><br><span class="line">    color:black;</span><br><span class="line">    font-family:arial;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="15-3、Id-和-Class选择器"><a href="#15-3、Id-和-Class选择器" class="headerlink" title="15-3、Id 和 Class选择器"></a>15-3、Id 和 Class选择器</h2><ul>
<li>id 选择器以 “#” 来定义。<br>下面的两个 id 选择器，第一个可以定义元素的颜色为红色，第二个定义元素的颜色为绿色：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#red &#123;</span><br><span class="line">	color:red;</span><br><span class="line">&#125;</span><br><span class="line">#green &#123;</span><br><span class="line">	color:green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>class 选择器<br>class 选择器用于描述一组元素的样式，class 选择器有别于id选择器，class可以在多个元素中使用,类选择器以一个点”.”号显示</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.red &#123;</span><br><span class="line">	color:red;</span><br><span class="line">&#125;</span><br><span class="line">.green &#123;</span><br><span class="line">	color:green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我们小程序的css中用的最多的就是id和class选择器。</p>
<h2 id="15-4、CSS-背景"><a href="#15-4、CSS-背景" class="headerlink" title="15-4、CSS 背景"></a>15-4、CSS 背景</h2><p>CSS 属性定义背景效果常用的方式:</p>
<ul>
<li>background-color（最常用）<br>background-color 属性定义了元素的背景颜色.如：<br>.title {background-color:red;} 就是设置类选择器title的背景颜色为红色</li>
</ul>
<p>我们上面的 background-color也可以简写为 background，如：<br>.title {background-color:red;}  也是设置背景为红色</p>
<h2 id="15-5、css中颜色设置的三种方式"><a href="#15-5、css中颜色设置的三种方式" class="headerlink" title="15-5、css中颜色设置的三种方式"></a>15-5、css中颜色设置的三种方式</h2><p>CSS中，颜色值通常以以下方式定义:</p>
<ul>
<li>十六进制 - 如：”#ff0000”</li>
<li>RGB - 如：”rgb(255,0,0)”</li>
<li>颜色名称 - 如：”red”</li>
<li>我这里给大家提供一个颜色表，大家可以拿到自己喜欢颜色的十六进制值。<br><a target="_blank" rel="noopener" href="https://tool.oschina.net/commons?type=3">https://tool.oschina.net/commons?type=3</a><br>如果这个连接失效了，大家自己百度下“颜色对照表”也可以找到类似的。</li>
</ul>
<p>部分截图如下。<br><img src="https://img-blog.csdnimg.cn/20201224151322333.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="15-6、文本常用样式"><a href="#15-6、文本常用样式" class="headerlink" title="15-6、文本常用样式"></a>15-6、文本常用样式</h2><h3 id="15-6-1、文本的对齐方式"><a href="#15-6-1、文本的对齐方式" class="headerlink" title="15-6-1、文本的对齐方式"></a>15-6-1、文本的对齐方式</h3><p>文本排列属性是用来设置文本的水平对齐方式。<br>文本可居中或对齐到左或右,两端对齐</p>
<ul>
<li>text-align: center； 文本居中对齐</li>
<li>text-align: left； 文本居左对齐</li>
<li>text-align: right； 文本居右对齐</li>
</ul>
<h3 id="15-6-2、文本修饰"><a href="#15-6-2、文本修饰" class="headerlink" title="15-6-2、文本修饰"></a>15-6-2、文本修饰</h3><p>text-decoration 属性用来设置或删除文本的装饰</p>
<ul>
<li>text-decoration: overline; 上划线<br><img src="https://img-blog.csdnimg.cn/20201224152359894.png" alt="img"></li>
<li>text-decoration: line-through; 中间划线<br><img src="https://img-blog.csdnimg.cn/20201224152458464.png" alt="img"></li>
<li>text-decoration:underline; 下划线<br><img src="https://img-blog.csdnimg.cn/20201224152542808.png" alt="img"></li>
</ul>
<h3 id="15-6-3、color设置文本颜色"><a href="#15-6-3、color设置文本颜色" class="headerlink" title="15-6-3、color设置文本颜色"></a>15-6-3、color设置文本颜色</h3><p>如下所示，设置字体颜色为红色的三种方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/* 英文颜色 */</span><br><span class="line">.title &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line">/* rgb设置颜色 */</span><br><span class="line">.title &#123;</span><br><span class="line">  color: rgb(255, 0, 0);</span><br><span class="line">&#125;</span><br><span class="line">/* 十六进制设置颜色 */</span><br><span class="line">.title &#123;</span><br><span class="line">  color: #FF0000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://img-blog.csdnimg.cn/20201224153147236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>这些颜色值，可以在我前面给到大家的颜色对照表里找到。</p>
<h3 id="15-6-4，font-size-设置字体大小"><a href="#15-6-4，font-size-设置字体大小" class="headerlink" title="15-6-4，font-size 设置字体大小"></a>15-6-4，font-size 设置字体大小</h3><p>可以自己去看下 <a target="_blank" rel="noopener" href="https://www.runoob.com/css/css-text.html">https://www.runoob.com/css/css-text.html</a></p>
<h2 id="15-7、css边框和边距"><a href="#15-7、css边框和边距" class="headerlink" title="15-7、css边框和边距"></a>15-7、css边框和边距</h2><p>元素框的最内部分是实际的内容，直接包围内容的是内边距。内边距呈现了元素的背景。内边距的边缘是边框。边框以外是外边距，外边距默认是透明的，因此不会遮挡其后的任何元素。<br><img src="https://img-blog.csdnimg.cn/20201224154827728.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>我这里画一个图，方便大家理解margin，padding，border。其实我们装手机的快递盒子有点类似。<br><img src="https://img-blog.csdnimg.cn/20201225174000202.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="15-7-1、padding-内边距"><a href="#15-7-1、padding-内边距" class="headerlink" title="15-7-1、padding 内边距"></a>15-7-1、padding 内边距</h3><p>元素的内边距在边框和内容区之间。控制该区域最简单的属性是 padding 属性。padding 属性定义元素边框与元素内容之间的空白区域。padding 属性接受像素值或百分比值，但不允许使用负值</p>
<ul>
<li>padding: 10px;<br>如果只设置一个值，那么上下左右都是10px</li>
<li>padding: 10px 20px 30px 40px;<br>按照上、右、下、左的顺序分别设置各边的内边距。这样设置就是内边距的上间距10px，右间距20px，下边距30px，左边距40px</li>
<li>也通过使用下面四个单独的属性，分别设置上、右、下、左内边距：<br>padding-top<br>padding-right<br>padding-bottom<br>padding-left<br><img src="https://img-blog.csdnimg.cn/20201224155732952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></li>
</ul>
<h3 id="15-7-2、border边框"><a href="#15-7-2、border边框" class="headerlink" title="15-7-2、border边框"></a>15-7-2、border边框</h3><p>元素的边框 (border) 是围绕元素内容和内边距的一条或多条线。<br>CSS border 属性允许你规定元素边框的样式、宽度和颜色。<br>如下面几种边框<br><img src="https://img-blog.csdnimg.cn/20201224160219664.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>每个边框有 3 个方面：样式，宽度、以及颜色</p>
<ul>
<li>border-style可以来设置样式<br>  <img src="https://img-blog.csdnimg.cn/20201224160755362.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>  我们通过设置border-style来定义上下左右四个边框样式，当让也可以定义单边样式，如果您希望为元素框的某一个边设置边框样式，而不是设置所有 4 个边的边框样式，可以使用下面的单边边框样式属性：<br>  border-top-style<br>  border-right-style<br>  border-bottom-style<br>  border-left-style </li>
<li>border-width设置边框的宽度<br>  您可以通过 border-width 属性为边框指定宽度。<br>  同样border-width: 5px;只有一个值的时候是设置上下左右4个边框的宽度。<br>  您也可以通过下列属性分别设置边框各边的宽度：<br>  border-top-width<br>  border-right-width<br>  border-bottom-width<br>  border-left-width </li>
<li>border-color设置边框的颜色<br>  您可以通过border-color 属性为边框指定颜色。<br>  同样border-color只有一个值的时候是设置上下左右4个边框的颜色。<br>  您也可以通过下列属性分别设置边框各边的颜色：<br>  border-top-color<br>  border-right-color<br>  border-bottom-color<br>  border-left-color </li>
<li>当然我们我们的边框宽度，样式，颜色有一种简写方式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.title&#123;</span><br><span class="line">  border:5px solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我们只需要一个border属性，就可以设置上下左右四个边框的宽度为5px，样式为solid，颜色为red。</p>
<h3 id="15-7-3、margin外边距"><a href="#15-7-3、margin外边距" class="headerlink" title="15-7-3、margin外边距"></a>15-7-3、margin外边距</h3><p>围绕在元素边框的空白区域是外边距。设置外边距会在元素外创建额外的“空白”。margin 没有背景颜色，是完全透明的<br>设置外边距的最简单的方法就是使用 margin 属性，这个属性接受任何长度单位、百分数值甚至负值<br><img src="https://img-blog.csdnimg.cn/20201224162251291.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<ul>
<li>Margin - 单边外边距属性<br>在CSS中，它可以指定不同的侧面不同的边距：<br>实例<br>margin-top:100px;<br>margin-bottom:100px;<br>margin-right:50px;<br>margin-left:50px;</li>
</ul>
<p>margin属性可以有一到四个值。</p>
<ul>
<li>margin:25px 50px 75px 100px;<br>上边距为25px<br>右边距为50px<br>下边距为75px<br>左边距为100px</li>
<li>margin:25px 50px 75px;<br>上边距为25px<br>左右边距为50px<br>下边距为75px</li>
<li>margin:25px 50px;<br>上下边距为25px<br>左右边距为50px</li>
<li>margin:25px;<br>所有的4个边距都是25px</li>
</ul>
<h2 id="15-8、border-radius设置圆角边框"><a href="#15-8、border-radius设置圆角边框" class="headerlink" title="15-8、border-radius设置圆角边框"></a>15-8、border-radius设置圆角边框</h2><p>border-radius 主要是用来设置圆角用的，下面我通过几个常用的例子来给大家讲解下这个知识点</p>
<ul>
<li>1，直接可以用像素设置圆角大小</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.title &#123;</span><br><span class="line">  background: red;</span><br><span class="line">  /* 可以用像素设置圆角 */</span><br><span class="line">  border-radius: 10px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<ul>
<li>2,如果有宽高值，可以设置border-radius为宽高的一半实现圆形</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.title &#123;</span><br><span class="line">  background: red;</span><br><span class="line">  width: 200px;</span><br><span class="line">  height: 200px;</span><br><span class="line">  border-radius: 100px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://img-blog.csdnimg.cn/20201225170735485.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>当有宽高的时候，设置 border-radius为50%同样可以实现上面的圆形功能。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.title &#123;</span><br><span class="line">  background: red;</span><br><span class="line">  width: 200px;</span><br><span class="line">  height: 200px;</span><br><span class="line">  border-radius: 50%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="15-9、综合案例一-画个月牙"><a href="#15-9、综合案例一-画个月牙" class="headerlink" title="15-9、综合案例一(画个月牙) "></a>15-9、综合案例一(画个月牙) <img src="https://img-blog.csdnimg.cn/20201225171436313.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></h2><ul>
<li>1，在wxml里定义两个view组件，并且设置好class类名<br><img src="https://img-blog.csdnimg.cn/20201225171546564.png" alt="img"></li>
<li>2，然后再wxss里设置对应的css样式，用到我们前面学的border-radius<br><img src="https://img-blog.csdnimg.cn/20201225171638467.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>可以看出来，我们就是用了border-radius实现了一个红色的圆形和一个白色的圆形，白色的圆形遮住了一部分红色的大圆，这样就实现了一个红色的月牙。</li>
</ul>
<h2 id="15-11、px和rpx的转换"><a href="#15-11、px和rpx的转换" class="headerlink" title="15-11、px和rpx的转换"></a>15-11、px和rpx的转换</h2><p>我们在设置宽度，高度，边框粗细时都会用到尺寸单位，我们这里重点给大家讲解下px和rpx。rpx是微信为小程序专门设计的一个尺寸单位。<br>px和rpx的换算如下：<br><img src="https://img-blog.csdnimg.cn/20201228104051894.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>一般设计规范都是依据iPhone6来设计的，也就是说平常ui设计师给出的1px我们在写代码时要写0.5rpx。</p>
<p>所以开发小程序里建议大家用rpx作为小程序的尺寸单位，这样能很好的做自适应。如果我们的设计小姐姐给的是px单位的设计图，我们就要自己用px除以2得到我们对应的rpx大小。</p>
<h1 id="十六、多媒体组件的学习（图片和视频）"><a href="#十六、多媒体组件的学习（图片和视频）" class="headerlink" title="十六、多媒体组件的学习（图片和视频）"></a>十六、多媒体组件的学习（图片和视频）</h1><h2 id="16-1、认识图片image组件"><a href="#16-1、认识图片image组件" class="headerlink" title="16-1、认识图片image组件"></a>16-1、认识图片image组件</h2><p>image组件：主要用来显示图片，可以是本地图片，也可以是网络图片。</p>
<p>官方学习文档：<a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/component/image.html">https://developers.weixin.qq.com/miniprogram/dev/component/image.html</a></p>
<h3 id="16-1-1、src属性显示网络图片"><a href="#16-1-1、src属性显示网络图片" class="headerlink" title="16-1-1、src属性显示网络图片"></a>16-1-1、src属性显示网络图片</h3><p>我们通过src属性来设置要显示的图片资源，图片资源有两种</p>
<ul>
<li>本地图片资源</li>
<li>网络图片资源</li>
</ul>
<p>由于我们本地的图片会占用小程序软件包的大小，所以这里推荐大家尽量使用网络图片。<br><img src="https://img-blog.csdnimg.cn/20210104201638769.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>我们设置显示图片的语法如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;image src=&quot;图片资源地址&quot;&gt;&lt;/image&gt;</span><br></pre></td></tr></table></figure>



<h3 id="16-1-2、src属性显示本地图片"><a href="#16-1-2、src属性显示本地图片" class="headerlink" title="16-1-2、src属性显示本地图片"></a>16-1-2、src属性显示本地图片</h3><p>用image显示本地图片，我们需要提前把图片放在小程序项目里，如下图我们把本地图片放在images目录里，这个images目录需要我们自己新建。<br>然后在image组件里设置src属性，指向这个本地图片，就可以在小程序里展示了。</p>
<h3 id="16-1-3、通过mode设置图片裁剪、缩放的模式"><a href="#16-1-3、通过mode设置图片裁剪、缩放的模式" class="headerlink" title="16-1-3、通过mode设置图片裁剪、缩放的模式"></a>16-1-3、通过mode设置图片裁剪、缩放的模式</h3><p>image组件另外一个比较重要的属性就是mode了。我们在使用图片时，不能百分之百保证图片的比例正好是我们想要的，这个时候就要用到图片的裁剪和缩放了。<br>mode 的常用设置如下</p>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>scaleToFill</td>
<td>缩放模式，不保持纵横比缩放图片，使图片的宽高完全拉伸至填满 image 元素</td>
</tr>
<tr>
<td>aspectFit</td>
<td>缩放模式，保持纵横比缩放图片，使图片的长边能完全显示出来。也就是说，可以完整地将图片显示出来。</td>
</tr>
<tr>
<td>aspectFill</td>
<td>缩放模式，保持纵横比缩放图片，只保证图片的短边能完全显示出来。也就是说，图片通常只在水平或垂直方向是完整的，另一个方向将会发生截取。</td>
</tr>
<tr>
<td>widthFix</td>
<td>缩放模式，宽度不变，高度自动变化，保持原图宽高比不变</td>
</tr>
<tr>
<td>heightFix</td>
<td>缩放模式，高度不变，宽度自动变化，保持原图宽高比不变	2.10.3</td>
</tr>
<tr>
<td>top</td>
<td>裁剪模式，不缩放图片，只显示图片的顶部区域</td>
</tr>
<tr>
<td>bottom</td>
<td>裁剪模式，不缩放图片，只显示图片的底部区域</td>
</tr>
<tr>
<td>center</td>
<td>裁剪模式，不缩放图片，只显示图片的中间区域</td>
</tr>
<tr>
<td>left</td>
<td>裁剪模式，不缩放图片，只显示图片的左边区域</td>
</tr>
<tr>
<td>right</td>
<td>裁剪模式，不缩放图片，只显示图片的右边区域</td>
</tr>
<tr>
<td>top left</td>
<td>裁剪模式，不缩放图片，只显示图片的左上边区域</td>
</tr>
<tr>
<td>top right</td>
<td>裁剪模式，不缩放图片，只显示图片的右上边区域</td>
</tr>
<tr>
<td>bottom left</td>
<td>裁剪模式，不缩放图片，只显示图片的左下边区域</td>
</tr>
<tr>
<td>bottom right</td>
<td>裁剪模式，不缩放图片，只显示图片的右下边区域</td>
</tr>
</tbody></table>
<p>比如我们有一个原图如下。<br><img src="https://img-blog.csdnimg.cn/20210104203418276.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>设置不同的mode值，可以很明显的看出来区别<br><img src="https://img-blog.csdnimg.cn/20210104203527548.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>后面我们需要对图片做裁剪或者伸缩处理时，就可以设置不同的mode值来实现不同的效果。</p>
<h3 id="16-1-4、图片懒加载"><a href="#16-1-4、图片懒加载" class="headerlink" title="16-1-4、图片懒加载"></a>16-1-4、图片懒加载</h3><p>小程序里image组件是支持图片懒加载的，当我们一个列表页有很多图片时，我们可以使用懒加载，来加快页面加载速度。使用懒加载时，我们只需要给image设置lazy-load就可以了。<br><img src="https://img-blog.csdnimg.cn/20210104204621150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="16-2、认识视频video组件"><a href="#16-2、认识视频video组件" class="headerlink" title="16-2、认识视频video组件"></a>16-2、认识视频video组件</h2><p>video组件：主要用来实现视频播放。</p>
<p>官方学习文档：<a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/component/video.html">https://developers.weixin.qq.com/miniprogram/dev/component/video.html</a></p>
<h3 id="16-2-1、src属性设置视频地址"><a href="#16-2-1、src属性设置视频地址" class="headerlink" title="16-2-1、src属性设置视频地址"></a>16-2-1、src属性设置视频地址</h3><p><img src="https://img-blog.csdnimg.cn/20210104204731972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>video组件里也是通过src属性来设置视频资源的。</p>
<h3 id="16-2-2，设置视频弹幕属性来显示弹幕"><a href="#16-2-2，设置视频弹幕属性来显示弹幕" class="headerlink" title="16-2-2，设置视频弹幕属性来显示弹幕"></a>16-2-2，设置视频弹幕属性来显示弹幕</h3><p>我们上面设置src只能保证视频的正常播放，如果我们想使用弹幕功能，就要为video设置别的属性了。<br><img src="https://img-blog.csdnimg.cn/20210104210554480.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>我们如果想在视频上显示弹幕，就要设置danmu-list属性。可以看出danmu-list属性是一个数组，而这个数组就要放置我们弹幕的一些数据了。<br><img src="https://img-blog.csdnimg.cn/20210104210725746.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>下面我在代码里给大家简单的演示下弹幕的显示。<br>首先在wxml里设置danmu-list属性，并且给danmu-list绑定数据danmuList<br><img src="https://img-blog.csdnimg.cn/20210104210925139.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>而这个danmuList就要在js里设置了。<br><img src="https://img-blog.csdnimg.cn/20210104211241948.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>我们可以在danmuList的每个弹幕对象里设置弹幕显示的内容，弹幕的颜色，弹幕显示的时间。</p>
<h3 id="16-2-3，发送弹幕功能"><a href="#16-2-3，发送弹幕功能" class="headerlink" title="16-2-3，发送弹幕功能"></a>16-2-3，发送弹幕功能</h3><p>我们上面只是简单的展示了弹幕，如果我们想让用户发送弹幕该怎么做呢。下面就来教大家实现弹幕的发送功能。<br>简单起见，我这里设置一个input来获取用户输入的内容，用一个button按钮来触发弹幕的发送。</p>
<p>wxml文件如下：<br><img src="https://img-blog.csdnimg.cn/20210104213340860.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>这里我们特意设置了一个id属性，我们下面发送弹幕时，需要先初始化一个视频对象，而初始化视频对象时就用到了这个id。</p>
<p>js文件如下：<br><img src="https://img-blog.csdnimg.cn/20210104212613321.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>在onReady页面渲染完成时，初始化了一个视频对象videoContext，然后通过bindInput获取用户输入的弹幕内容。最后在点击发送弹幕按钮时，通过videoContext.sendDanmu来发送弹幕到视频的屏幕上。<br>官方文档：<br><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/component/video.html">https://developers.weixin.qq.com/miniprogram/dev/component/video.html</a></p>
<h1 id="十七、授权登录退出和缓存"><a href="#十七、授权登录退出和缓存" class="headerlink" title="十七、授权登录退出和缓存"></a>十七、授权登录退出和缓存</h1><p>我们的项目开发多多少少的都会用到用户的一些信息，比如头像，昵称，性别等。而这些信息的获取，小程序也为我们提供好了方法。</p>
<h2 id="17-1、认识wx-login方法"><a href="#17-1、认识wx-login方法" class="headerlink" title="17-1、认识wx.login方法"></a>17-1、认识wx.login方法</h2><p>对应的文档：<a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/api/open-api/user-info/wx.getUserProfile.html">https://developers.weixin.qq.com/miniprogram/dev/api/open-api/user-info</a></p>
<p>使用这个方法可以获取如下的用户信息<br><img src="https://pic.imgdb.cn/item/63d68820face21e9ef47802b.png"></p>
<h2 id="17-2、授权弹窗"><a href="#17-2、授权弹窗" class="headerlink" title="17-2、授权弹窗"></a>17-2、授权弹窗</h2><p>一般我的使用上面的wx.login()方法获取用户信息时，需要用户授权的。一般授权弹窗如下。<br><img src="https://pic.imgdb.cn/item/63d6882cface21e9ef47aa9e.png"><br>只有用户点击允许以后才可以获取用户信息。</p>
<h3 id="不弹起授权弹窗解决方案"><a href="#不弹起授权弹窗解决方案" class="headerlink" title="不弹起授权弹窗解决方案"></a>不弹起授权弹窗解决方案</h3><p>有的同学用这个方法时，不会弹起上面的弹窗，有可能是因为基础库版本太低，这里建议升级到最新版的基础库。<br><img src="https://img-blog.csdnimg.cn/20210514110150215.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="17-3、授权登录核心代码"><a href="#17-3、授权登录核心代码" class="headerlink" title="17-3、授权登录核心代码"></a>17-3、授权登录核心代码</h2><p>其实核心代码官方文档里有提供的。<br><img src="https://pic.imgdb.cn/item/63d68842face21e9ef47e81d.png"></p>
<h2 id="17-4、顶部圆形头像和昵称"><a href="#17-4、顶部圆形头像和昵称" class="headerlink" title="17-4、顶部圆形头像和昵称"></a>17-4、顶部圆形头像和昵称</h2><p><img src="https://pic.imgdb.cn/item/63d6884eface21e9ef480b36.png"><br>其实这里倒是挺简单，重点知识只有一个圆形图片的实现这里只需要一个image组件和一个text组件即可。通过css的border-radius就可以来设置圆形图像了。<br><img src="https://img-blog.csdnimg.cn/20210514110843559.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="17-5、本地缓存的讲解"><a href="#17-5、本地缓存的讲解" class="headerlink" title="17-5、本地缓存的讲解"></a>17-5、本地缓存的讲解</h2><h3 id="17-5-1、使用wx-setStorageSync缓存"><a href="#17-5-1、使用wx-setStorageSync缓存" class="headerlink" title="17-5-1、使用wx.setStorageSync缓存"></a>17-5-1、使用wx.setStorageSync缓存</h3><p>这里缓存我们主要用到了wx.setStorageSync 对应的官方文档：<br><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/api/storage/wx.setStorageSync.html">https://developers.weixin.qq.com/miniprogram/dev/api/storage/wx.setStorageSync.html</a><br><img src="https://img-blog.csdnimg.cn/2021051411134147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="17-5-2、缓存数据的查看"><a href="#17-5-2、缓存数据的查看" class="headerlink" title="17-5-2、缓存数据的查看"></a>17-5-2、缓存数据的查看</h3><p>本地缓存数据<br><img src="https://pic.imgdb.cn/item/63d68864face21e9ef484c30.png"></p>
<h3 id="17-5-3、使用wx-getStorageSync获取缓存"><a href="#17-5-3、使用wx-getStorageSync获取缓存" class="headerlink" title="17-5-3、使用wx.getStorageSync获取缓存"></a>17-5-3、使用wx.getStorageSync获取缓存</h3><p><img src="https://img-blog.csdnimg.cn/20210514111636364.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>对应的官方文档：<a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/api/storage/wx.getStorageSync.html">https://developers.weixin.qq.com/miniprogram/dev/api/storage/wx.getStorageSync.html</a></p>
<h2 id="17-6、退出登录的编写"><a href="#17-6、退出登录的编写" class="headerlink" title="17-6、退出登录的编写"></a>17-6、退出登录的编写</h2><p>退出登录其实很简单，就实现一个点击事件就可以了<br><img src="https://pic.imgdb.cn/item/63d68864face21e9ef484c30.png"><br>然后js里具体代码就下面这几行就够了<br><img src="https://pic.imgdb.cn/item/63d6888aface21e9ef48b195.png"></p>
<h2 id="17-7、案例代码-index-wxml"><a href="#17-7、案例代码-index-wxml" class="headerlink" title="17-7、案例代码 index.wxml"></a>17-7、案例代码 index.wxml</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;button wx:if=&quot;&#123;&#123;!userInfo&#125;&#125;&quot; bindtap=&quot;login&quot;&gt;授权登录&lt;/button&gt;</span><br><span class="line">&lt;view wx:else class=&quot;root&quot;&gt;</span><br><span class="line">  &lt;image class=&quot;touxiang&quot; src=&quot;&#123;&#123;userInfo.avatarUrl&#125;&#125;&quot;&gt;&lt;/image&gt;</span><br><span class="line">  &lt;text class=&quot;nicheng&quot;&gt;&#123;&#123;userInfo.nickName&#125;&#125;&lt;/text&gt;</span><br><span class="line">  &lt;button bindtap=&quot;loginOut&quot;&gt;退出登录&lt;/button&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure>



<p>index.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    userInfo: &#x27;&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  onLoad() &#123;</span><br><span class="line">    let user = wx.getStorageSync(&#x27;user&#x27;)</span><br><span class="line">    console.log(&#x27;进入小程序的index页面获取缓存&#x27;, user)</span><br><span class="line">    this.setData(&#123;</span><br><span class="line">      userInfo: user</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  // 授权登录</span><br><span class="line">  login() &#123;</span><br><span class="line">    wx.getUserProfile(&#123;</span><br><span class="line">      desc: &#x27;必须授权才可以继续使用&#x27;,</span><br><span class="line">      success: res =&gt; &#123;</span><br><span class="line">        let user = res.userInfo</span><br><span class="line">        // 把用户信息缓存到本地</span><br><span class="line">        wx.setStorageSync(&#x27;user&#x27;, user)</span><br><span class="line">        console.log(&quot;用户信息&quot;, user)</span><br><span class="line">        this.setData(&#123;</span><br><span class="line">          userInfo: user</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;,</span><br><span class="line">      fail: res =&gt; &#123;</span><br><span class="line">        console.log(&#x27;授权失败&#x27;, res)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  // 退出登录</span><br><span class="line">  loginOut() &#123;</span><br><span class="line">    this.setData(&#123;</span><br><span class="line">      userInfo: &#x27;&#x27;</span><br><span class="line">    &#125;)</span><br><span class="line">    wx.setStorageSync(&#x27;user&#x27;, null)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>index.wxss</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.root &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  flex-direction: column;</span><br><span class="line">  align-items: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.touxiang &#123;</span><br><span class="line">  width: 200rpx;</span><br><span class="line">  height: 200rpx;</span><br><span class="line">  border-radius: 50%;</span><br><span class="line">  margin-top: 30rpx;</span><br><span class="line">  margin-bottom: 10rpx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="十八、swiper轮播图组件"><a href="#十八、swiper轮播图组件" class="headerlink" title="十八、swiper轮播图组件"></a>十八、swiper轮播图组件</h1><h2 id="18-1、swiper组件"><a href="#18-1、swiper组件" class="headerlink" title="18-1、swiper组件"></a>18-1、swiper组件</h2><p>官方文档：<a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/component/swiper.html">https://developers.weixin.qq.com/miniprogram/dev/component/swiper.html</a></p>
<p>如下图<br><img src="https://img-blog.csdnimg.cn/20210105160644563.png" alt="img"><br>给大家看下官方swiper简介<br><img src="https://img-blog.csdnimg.cn/20210105160749113.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>可以看出我们的swiper必须结合swiper-item来使用。</p>
<h2 id="18-2、swiper-item组件"><a href="#18-2、swiper-item组件" class="headerlink" title="18-2、swiper-item组件"></a>18-2、swiper-item组件</h2><p>我们的swiper-item就是用来装每个轮播图使用的。<br><img src="https://pic.imgdb.cn/item/63d688a1face21e9ef48eec7.png"></p>
<h2 id="18-3、swiper-item组件里显示轮播图-案例代码"><a href="#18-3、swiper-item组件里显示轮播图-案例代码" class="headerlink" title="18-3、swiper-item组件里显示轮播图 案例代码"></a>18-3、swiper-item组件里显示轮播图 案例代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;swiper indicator-dots&gt;</span><br><span class="line">  &lt;swiper-item&gt;</span><br><span class="line">    &lt;image src=&quot;https://res.wx.qq.com/wxdoc/dist/assets/img/0.4cb08bb4.jpg&quot; /&gt;</span><br><span class="line">  &lt;/swiper-item&gt;</span><br><span class="line">  &lt;swiper-item&gt;</span><br><span class="line">    &lt;image src=&quot;https://dss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=1819216937,2118754409&amp;fm=26&amp;gp=0.jpg&quot; /&gt;</span><br><span class="line">  &lt;/swiper-item&gt;</span><br><span class="line">  &lt;swiper-item&gt;</span><br><span class="line">    &lt;image src=&quot;https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=2273029747,2912173232&amp;fm=15&amp;gp=0.jpg&quot; /&gt;</span><br><span class="line">  &lt;/swiper-item&gt;</span><br><span class="line">&lt;/swiper&gt;</span><br></pre></td></tr></table></figure>



<h2 id="18-4、swiper的常用属性。"><a href="#18-4、swiper的常用属性。" class="headerlink" title="18-4、swiper的常用属性。"></a>18-4、swiper的常用属性。</h2><p>可以看出我们的swiper有很多属性，下面我会重点的把我们一些常用的属性，通过视频里的一个综合案例来给大家讲解下。</p>
<p>还是来看官方文档：<a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/component/swiper.html">https://developers.weixin.qq.com/miniprogram/dev/component/swiper.html</a><br><img src="https://img-blog.csdnimg.cn/2021010516274396.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<h1 id="十九、通过tabBar设置多页面"><a href="#十九、通过tabBar设置多页面" class="headerlink" title="十九、通过tabBar设置多页面"></a>十九、通过tabBar设置多页面</h1><p>我们正常创建的默认项目是一个单页面，我们要想实现下面效果所示的多页面就要借助tabBar来实现多页面。</p>
<p>官方文档：<a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#%E9%85%8D%E7%BD%AE%E9%A1%B9">https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#配置项</a></p>
<p><img src="https://img-blog.csdnimg.cn/20210622174333805.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>一个小程序可以配置2-5个多页面，<br><img src="https://img-blog.csdnimg.cn/202106221744101.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>我们这里以创建3个页面来给大家做下讲解。<br><img src="https://img-blog.csdnimg.cn/20201223111650910.png" alt="img"></p>
<h2 id="19-1、创建image目录放图标"><a href="#19-1、创建image目录放图标" class="headerlink" title="19-1、创建image目录放图标"></a>19-1、创建image目录放图标</h2><p>我们要使用tabBar就需要用到图标，所以我们要创建一个放图标的目录。<br><img src="https://pic.imgdb.cn/item/63d688b6face21e9ef4925ad.png"></p>
<h2 id="19-2、创建多个页面"><a href="#19-2、创建多个页面" class="headerlink" title="19-2、创建多个页面"></a>19-2、创建多个页面</h2><p>在app.json里创建</p>
<p><img src="https://pic.imgdb.cn/item/63d688c0face21e9ef493fd7.png"></p>
<h2 id="19-3、设置tabBar实现多页面布局"><a href="#19-3、设置tabBar实现多页面布局" class="headerlink" title="19-3、设置tabBar实现多页面布局"></a>19-3、设置tabBar实现多页面布局</h2><p>上面三个页面创建好以后，我们就可以通过tabBar来设置多页面布局了。<br>在app.json里添加如下配置。<br><img src="https://img-blog.csdnimg.cn/20201223112508863.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>这样我们就可以实现可以自由切换的多页面小程序了。<br><img src="https://img-blog.csdnimg.cn/20201223112620746.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="19-4、设置tabbar的代码"><a href="#19-4、设置tabbar的代码" class="headerlink" title="19-4、设置tabbar的代码"></a>19-4、设置tabbar的代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&quot;tabBar&quot;: &#123;</span><br><span class="line">    &quot;color&quot;: &quot;#Fc0&quot;,</span><br><span class="line">    &quot;selectedColor&quot;: &quot;#f4c903&quot;,</span><br><span class="line">    &quot;borderStyle&quot;: &quot;white&quot;,</span><br><span class="line">    &quot;list&quot;: [&#123;</span><br><span class="line">        &quot;selectedIconPath&quot;: &quot;image/tab1-ok.png&quot;,</span><br><span class="line">        &quot;iconPath&quot;: &quot;image/tab1.png&quot;,</span><br><span class="line">        &quot;pagePath&quot;: &quot;pages/home/home&quot;,</span><br><span class="line">        &quot;text&quot;: &quot;首页&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;selectedIconPath&quot;: &quot;image/tab2-ok.png&quot;,</span><br><span class="line">        &quot;iconPath&quot;: &quot;image/tab2.png&quot;,</span><br><span class="line">        &quot;pagePath&quot;: &quot;pages/me/me&quot;,</span><br><span class="line">        &quot;text&quot;: &quot;我的&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>



<h1 id="二十、navigator页面跳转"><a href="#二十、navigator页面跳转" class="headerlink" title="二十、navigator页面跳转"></a>二十、navigator页面跳转</h1><p>在小程序里做页面跳转有两种方式</p>
<ul>
<li>1，借助navigator组件</li>
<li>2，借助wx.自带方法，在点击的时候做页面跳转<br>如下图所示的几个wx.方法<br><img src="https://img-blog.csdnimg.cn/2021010516140378.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>官方给出的几种跳转方式的解释如下<br><img src="https://img-blog.csdnimg.cn/20210622173323610.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></li>
</ul>
<h2 id="20-1、navigator实现页面跳转"><a href="#20-1、navigator实现页面跳转" class="headerlink" title="20-1、navigator实现页面跳转"></a>20-1、navigator实现页面跳转</h2><p>navigator其实和我们html里的a标签有点像，也是为了实现页面跳转的。<br>官方文档：<a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html">https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html</a></p>
<p>当然了我们使用navigator来跳转页面时，分下面几种情况。当然这些跳转方式都是通过配置open-type属性来定义的。<br><img src="https://img-blog.csdnimg.cn/20210106205014426.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="20-2、页面的跳转方式"><a href="#20-2、页面的跳转方式" class="headerlink" title="20-2、页面的跳转方式"></a>20-2、页面的跳转方式</h2><p>下面我把一些常用的open-type属性列出来给大家，方便大家以后使用。</p>
<table>
<thead>
<tr>
<th>open-type值</th>
<th>说明</th>
<th>对应wx方法</th>
</tr>
</thead>
<tbody><tr>
<td>navigate</td>
<td>保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面</td>
<td>对应wx.navigateTo</td>
</tr>
<tr>
<td>redirect</td>
<td>关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到 tabbar 页面</td>
<td>对应 wx.redirectTo</td>
</tr>
<tr>
<td>switchTab</td>
<td>跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面</td>
<td>对应 wx.switchTab</td>
</tr>
<tr>
<td>reLaunch</td>
<td>关闭所有页面，打开到应用内的某个页面</td>
<td>对应 wx.reLaunch</td>
</tr>
<tr>
<td>navigateBack</td>
<td>关闭当前页面，返回上一页面或多级页面</td>
<td>对应 wx.navigateBack</td>
</tr>
<tr>
<td>exit</td>
<td>退出小程序，target&#x3D;”miniProgram”时生效</td>
<td>无</td>
</tr>
</tbody></table>
<p>如我们使用navigate做页面跳转，只写个url属性，open-type的值默认就是navigate</p>
<p>跳转到新页面后，会有一个返回按钮。我们可以通过这个返回按钮返回上一个页面。</p>
<h2 id="20-3，点击事件结合wx方法实现跳转"><a href="#20-3，点击事件结合wx方法实现跳转" class="headerlink" title="20-3，点击事件结合wx方法实现跳转"></a>20-3，点击事件结合wx方法实现跳转</h2><p>我们做页面跳转除了使用navigate组件外，还可以通过点击事件借助wx方法实现页面跳转。</p>
<p>常用的wx方法：</p>
<table>
<thead>
<tr>
<th>wx方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>wx.navigateTo</td>
<td>保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面</td>
</tr>
<tr>
<td>wx.redirectTo</td>
<td>关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到 tabbar 页面</td>
</tr>
<tr>
<td>wx.switchTab</td>
<td>跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面</td>
</tr>
<tr>
<td>wx.reLaunch</td>
<td>关闭所有页面，打开到应用内的某个页面</td>
</tr>
<tr>
<td>wx.navigateBack</td>
<td>关闭当前页面，返回上一页面或多级页面</td>
</tr>
<tr>
<td>我这里给大家举个简单的例子</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>在wxml里设置点击事件<br><img src="https://img-blog.csdnimg.cn/20210106212455465.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></li>
<li>然后再js里设置点击后跳转页面<br><img src="https://img-blog.csdnimg.cn/20210106212535285.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"><br>这样就可以实现页面跳转了，和使用navigate做跳转一样的效果。<br>其余的几个wx跳转方法，我也会在视频里给大家做演示。</li>
</ul>
<h2 id="20-4，通过switchTab跳转tabbar页面如何携带数据"><a href="#20-4，通过switchTab跳转tabbar页面如何携带数据" class="headerlink" title="20-4，通过switchTab跳转tabbar页面如何携带数据"></a>20-4，通过switchTab跳转tabbar页面如何携带数据</h2><p>我们跳转到tabbar页面是无法直接通过url携带数据，所以我们就要通过别的方式来实现页面跳转时的数据传递，所以这时候可以有两个方式。具体代码我在视频里带大家写一遍。</p>
<h3 id="20-4-1、通过app-js里的globalData"><a href="#20-4-1、通过app-js里的globalData" class="headerlink" title="20-4-1、通过app.js里的globalData"></a>20-4-1、通过app.js里的globalData</h3><p>其实就是通过app.js里的全局变量来传递。</p>
<h3 id="20-4-2、通过本地缓存"><a href="#20-4-2、通过本地缓存" class="headerlink" title="20-4-2、通过本地缓存"></a>20-4-2、通过本地缓存</h3><p>其实就是在A页面存数据到缓存，然后A页面跳转到B页面时通过取本地缓存来拿到数据，进而实现页面跳转传递参数的功能。</p>
<h2 id="20-5、打开别的小程序"><a href="#20-5、打开别的小程序" class="headerlink" title="20-5、打开别的小程序"></a>20-5、打开别的小程序</h2><p>其实我们可以在自己的小程序里通过navigateTo打开别的小程序的，只不过有自己特定的方法：wx.navigateToMiniProgram<br>对应的官方文档：<a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/api/navigate/wx.navigateToMiniProgram.html">https://developers.weixin.qq.com/miniprogram/dev/api/navigate/wx.navigateToMiniProgram.html</a><br><img src="https://img-blog.csdnimg.cn/17eb8d80b92a4be2928744e44f4af1cc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA57yW56iL5bCP55-z5aS0,size_16,color_FFFFFF,t_70,g_se,x_16" alt="img"><br>其实只需要拿到别的小程序的appid就可以实现这个功能了。</p>
<h1 id="二十一、小程序页面生命周期"><a href="#二十一、小程序页面生命周期" class="headerlink" title="二十一、小程序页面生命周期"></a>二十一、小程序页面生命周期</h1><h2 id="什么是生命周期"><a href="#什么是生命周期" class="headerlink" title="什么是生命周期"></a>什么是生命周期</h2><p><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/page-life-cycle.html">https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/page-life-cycle.html</a><br>这是官方给出的页面生命周期解释，如下图<br><img src="https://img-blog.csdnimg.cn/328a6cea2929405f8e988467ea6337f5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA57yW56iL5bCP55-z5aS0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><br>作为初学者，一开始不一定能看懂，所以我给大家总结成下面所示的。方便大家学习。其实生命周期就是一个小程序页面从创建到销毁的一个时间周期。<br><img src="https://img-blog.csdnimg.cn/20210121203933666.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h2><p><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html">https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html</a></p>
<p><img src="https://img-blog.csdnimg.cn/e3e686d8e7d0488c8721dec24de43176.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA57yW56iL5bCP55-z5aS0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<h1 id="二十二、小程序应用生命周期"><a href="#二十二、小程序应用生命周期" class="headerlink" title="二十二、小程序应用生命周期"></a>二十二、小程序应用生命周期</h1><p><img src="https://img-blog.csdnimg.cn/20210121203911422.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="官方文档-1"><a href="#官方文档-1" class="headerlink" title="官方文档"></a>官方文档</h2><p><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html">https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html</a></p>
<p>这里最常用的就是下面3个</p>
<h3 id="onLaunch"><a href="#onLaunch" class="headerlink" title="onLaunch()"></a>onLaunch()</h3><p>小程序初始化完成时触发，全局只触发一次。</p>
<h3 id="onShow"><a href="#onShow" class="headerlink" title="onShow()"></a>onShow()</h3><p>小程序启动，或从后台进入前台显示时触发</p>
<h3 id="onHide"><a href="#onHide" class="headerlink" title="onHide()"></a>onHide()</h3><p>小程序从前台进入后台时触发</p>
<h1 id="二十三、scrollview讲解"><a href="#二十三、scrollview讲解" class="headerlink" title="二十三、scrollview讲解"></a>二十三、scrollview讲解</h1><h2 id="23-1、认识scrollview"><a href="#23-1、认识scrollview" class="headerlink" title="23-1、认识scrollview"></a>23-1、认识scrollview</h2><p>首先要去看下官方文档<br><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/component/scroll-view.html">https://developers.weixin.qq.com/miniprogram/dev/component/scroll-view.html</a><br><img src="https://img-blog.csdnimg.cn/c8426616bcb14000a67cb3fee4a8c40a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA57yW56iL5bCP55-z5aS0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<h2 id="23-2、快速创建100个view快捷方式"><a href="#23-2、快速创建100个view快捷方式" class="headerlink" title="23-2、快速创建100个view快捷方式"></a>23-2、快速创建100个view快捷方式</h2><p>先教大家一个在wxml页面里快速创建100行view代码的快捷方式<br>输入  view{$}*100  然后回车键，就可以在页面里快速创建100行view了。<br><img src="https://img-blog.csdnimg.cn/20210131094725604.png" alt="img"></p>
<h2 id="23-3、设置列表条目隔行不同颜色"><a href="#23-3、设置列表条目隔行不同颜色" class="headerlink" title="23-3、设置列表条目隔行不同颜色"></a>23-3、设置列表条目隔行不同颜色</h2><p>效果图如下：<br><img src="https://img-blog.csdnimg.cn/a95eb958c0f649b1ace6ab17727d133c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA57yW56iL5bCP55-z5aS0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><br>其实这是借助我们css的 :nth-child知识点，如上图所示:nth-child(2n)就是设置偶数行，:nth-child(1n)就是设置奇数行。</p>
<h2 id="23-4、一键置顶，回到列表页面顶部"><a href="#23-4、一键置顶，回到列表页面顶部" class="headerlink" title="23-4、一键置顶，回到列表页面顶部"></a>23-4、一键置顶，回到列表页面顶部</h2><p>主要是借助scroll-view的scroll-top属性，我会在视频里手把手的教大家实现这个功能的<br><img src="https://img-blog.csdnimg.cn/c2ecade32dcf4aaaa05e3a021722e718.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA57yW56iL5bCP55-z5aS0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<h2 id="23-5、让列表里的任意位置滚动到顶部"><a href="#23-5、让列表里的任意位置滚动到顶部" class="headerlink" title="23-5、让列表里的任意位置滚动到顶部"></a>23-5、让列表里的任意位置滚动到顶部</h2><p>主要是借助scroll-view的scroll-into-view属性，我会在视频里手把手的教大家实现这个功能的<br><img src="https://img-blog.csdnimg.cn/458b11911f7f43ae94d815393de6e8d9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA57yW56iL5bCP55-z5aS0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><br>注意事项：如上图所示，我们需要给每个条目设置一个id，并且这个id不能是数字开头。<br><img src="https://img-blog.csdnimg.cn/c3003609f931464fa5fd195385552cfa.png" alt="img"><br>对应的js代码如下：<br><img src="https://img-blog.csdnimg.cn/d9f7fad647954a8e97d0177df86f5c3b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA57yW56iL5bCP55-z5aS0,size_18,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<h1 id="二十四、注册小程序"><a href="#二十四、注册小程序" class="headerlink" title="二十四、注册小程序"></a>二十四、注册小程序</h1><p>我们前面虽然可以用测试号创建小程序,但是测试号有很多功能会受限,比如我们接下来要讲的云开发,必须是注册小程序后才可以使用,所以今天我们就来讲讲小程序的注册.</p>
<h2 id="24-1、其实官方给的注册步骤很详细了"><a href="#24-1、其实官方给的注册步骤很详细了" class="headerlink" title="24-1、其实官方给的注册步骤很详细了"></a>24-1、其实官方给的注册步骤很详细了</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/9620803e90a57d6ce600cdb5cafced2f.png" alt="img"><br>官方注册文档:<a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/introduction/">https://developers.weixin.qq.com/miniprogram/introduction/</a></p>
<p>微信小程序注册地址：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/">https://mp.weixin.qq.com/</a><br>进去以后点击立即注册<br><img src="https://img-blog.csdnimg.cn/20210118170514905.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpdXNoaV8xOTkw,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>进入注册页面时,跟着提示一步步来就可以了<br><img src="https://img-blog.csdnimg.cn/img_convert/b4e63808210224e80f8a5ecec6d9bc6a.png" alt="img"></p>
<h2 id="24-2、注意点"><a href="#24-2、注意点" class="headerlink" title="24-2、注意点"></a>24-2、注意点</h2><ul>
<li>如果只是学习的话,注册个人小程序即可.</li>
<li>如果想商用,想使用微信支付,取用户手机号等复杂功能,可以注册企业小程序,不过企业小程序必须有营业执照才可以注册</li>
<li>一个邮箱只能注册一个小程序</li>
<li>一个身份证可以注册5个，个人小程序</li>
<li>一个企业的营业执照可以注册50个企业小程序</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/">上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022-2023
        <i class="ri-heart-fill heart_icon"></i> Jelly Chen
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src=''></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="http://shenyu-vip.lofter.com">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/mypay_alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/mypay_wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->
 <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.staticfile.org/mathjax/2.7.7/MathJax.js"></script>
<script src="https://cdn.staticfile.org/mathjax/2.7.7/config/TeX-AMS-MML_HTMLorMML-full.js"></script>
<script>
  var ayerConfig = {
    mathjax: true,
  };
</script>

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=2017680379&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    

  </div>
</body>

</html>